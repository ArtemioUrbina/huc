/* ISOLINK
 *
 * This program appends the IPL header together with
 * a list of binary segments which may be overlays or
 * data, and produces an ISO output file
 *
 * An array of segment information is also produced and
 * stored (I'm not sure where yet)
 *
 */


/*************/
/* INCLUDES  */
/*************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include "main.h"
#include "../../include/overlay.h"


/*************/
/* DEFINES   */
/*************/

#define OVERLAY_SUFFIX  "ovl"


/*************/
/* GLOBALS   */
/*************/

int sector_array[200][2];
int array_count;
int cderr_flag = 0;
int cderr_ovl = 0;
static char incpath[10][256];
static int debug;


/*************/
/* CODE      */
/*************/

unsigned char *
prepare_ipl(unsigned char * dst)
{
   unsigned cmd;
   unsigned len;
   unsigned char * src;
   unsigned char * win;

   static unsigned char disc_header [1047] = {
      0x71,0x36,0x28,0x1B,0x28,0x66,0x29,0xDC,0x29,0x27,0x29,0xE5,0x29,0x23,0x29,0x2A,
      0x28,0x66,0x38,0x32,0x27,0x46,0x26,0x0A,0x28,0x67,0x20,0x3E,0x24,0x04,0x23,0x45,
      0x24,0x7A,0xAA,0x29,0xC4,0x29,0xC2,0x29,0xF6,0x29,0x39,0x28,0x00,0x25,0x20,0x3D,
      0xE6,0x28,0x1F,0x28,0x6E,0x28,0x02,0x28,0x42,0x28,0x76,0x28,0x1D,0x2B,0xE8,0xC3,
      0x19,0xAA,0xC2,0x40,0x22,0x40,0x3F,0x3E,0xE5,0x50,0x17,0x28,0x67,0x3B,0xF9,0xF6,
      0x11,0x5A,0xBA,0x11,0xAA,0xB9,0x06,0xBA,0x70,0x21,0x66,0x25,0x3B,0x3C,0x60,0x28,
      0x63,0x28,0x4C,0x28,0x43,0x21,0x3C,0x23,0x68,0x28,0x62,0x28,0x07,0xAA,0x3F,0x0B,
      0x24,0x60,0x2B,0xEF,0x3F,0x0B,0x3A,0x11,0x2B,0xEF,0x39,0xF7,0x3D,0xDA,0x28,0x1D,
      0x28,0x43,0xA5,0x33,0x6C,0x28,0x67,0x72,0x32,0xAA,0x3C,0xEA,0xCE,0x79,0x02,0x42,
      0x21,0x7C,0x28,0x1C,0x28,0x4D,0x28,0x40,0x7C,0x72,0x2C,0xAA,0x55,0xFA,0xF8,0xE5,
      0xEE,0xFF,0xE9,0xEF,0xF8,0xAA,0x38,0x2C,0x3C,0xD1,0x3A,0xE6,0x22,0x40,0xAA,0xEE,
      0xE3,0xF8,0xEF,0xE9,0xFE,0xE5,0xF8,0xAA,0x3C,0x46,0x3B,0x58,0x25,0x35,0x27,0xE6,
      0xAA,0xE9,0xEE,0x87,0xF8,0xE5,0xE7,0x8A,0xF9,0xE3,0xE7,0xFF,0xE6,0xEB,0xE6,0x70,
      0x11,0xD1,0x3E,0x3D,0x3C,0xEC,0x3F,0xDC,0xAA,0xE8,0xE3,0xE5,0xF9,0x8A,0xE7,0xEB,
      0xE3,0xE4,0x8A,0xE9,0xE5,0xEE,0xEF,0x86,0x8A,0xD6,0x40,0xFA,0xE6,0xEB,0xF3,0xB1,
      0x73,0x01,0x25,0x06,0x3D,0x7B,0x26,0xC2,0x24,0x5D,0xDD,0x70,0x03,0xE9,0xE2,0xEF,
      0xE9,0xE1,0x8A,0xE7,0xE5,0xE4,0xE3,0xC1,0x60,0x86,0x8A,0xF9,0xF8,0xEB,0xE7,0xC9,
      0x30,0xE4,0xEB,0xED,0xD6,0x72,0x0F,0x3E,0x58,0x39,0xC9,0x23,0x41,0x27,0xED,0xAA,
      0xE8,0xEB,0xE9,0xE1,0xFF,0xFA,0x8A,0xE7,0xEF,0xE7,0xE5,0xF8,0xF3,0xAA,0x76,0x0A,
      0xFE,0xEF,0xE4,0xEB,0xE4,0xE9,0xEF,0xAA,0x21,0x4A,0x39,0xC9,0x27,0xEC,0x24,0xC3,
      0xAA,0xA0,0x77,0x22,0x8A,0xF9,0xFF,0xE8,0xAA,0x24,0xE5,0x25,0x49,0x2B,0xEA,0x39,
      0xE4,0xAA,0xFA,0xF9,0xED,0x8A,0xEE,0xF8,0xE3,0xFC,0xEF,0xF8,0xAA,0x20,0x48,0x3F,
      0x09,0x21,0xE7,0x27,0xE1,0xAA,0xED,0xF8,0xEB,0xFA,0xE2,0xE3,0xE9,0xE8,0x6A,0x27,
      0x42,0x26,0xF1,0x3A,0xF4,0xE8,0x04,0xB8,0x7A,0x15,0x21,0xD3,0x3A,0x46,0x27,0x24,
      0x3E,0xFC,0xAA,0x92,0xD2,0x92,0x8A,0xEB,0xE4,0xE1,0x8A,0xEC,0xE5,0xE4,0xFE,0xAA,
      0x25,0x16,0x23,0xF3,0x27,0xF5,0x8B,0x70,0x06,0xEE,0xEF,0xF9,0xE3,0xED,0xE4,0xAA,
      0x22,0x63,0x39,0x0B,0x3A,0xF4,0x24,0x55,0xFE,0xE3,0xFE,0xE6,0xEF,0xEA,0x73,0x0D,
      0x3F,0x3A,0x39,0xC9,0x3A,0xF4,0x3D,0x37,0xAA,0x9B,0x98,0xD2,0x9B,0x98,0x8A,0xE1,
      0xEB,0xE4,0xE0,0xE3,0xB6,0x40,0x20,0xDA,0x38,0xE0,0x58,0x1F,0x6E,0xE6,0x00,0x7F,
      0x01,0x24,0xF8,0x26,0x51,0x28,0x4A,0x28,0x6C,0xE6,0x00,0x7F,0x20,0x23,0x00,0x39,
      0xC9,0x24,0x5F,0x3F,0xDC,0xAA,0xE4,0xEF,0xE9,0x8A,0xE2,0xC5,0xC7,0xCF,0x8A,0xEF,
      0xC6,0xCF,0xC9,0xDE,0xC5,0xD8,0xC5,0xC4,0xC3,0xC9,0xD9,0xAA,0x3D,0x43,0x3C,0x72,
      0x27,0xEC,0x24,0x0B,0xE1,0x05,0x7F,0x01,0x3C,0xDB,0x3C,0x46,0x2B,0xEA,0x27,0xEC,
      0xE1,0x05,0x7F,0x01,0x23,0xDC,0x24,0xDB,0x3B,0x7D,0x25,0x04,0xC2,0x06,0x6F,0x46,
      0x27,0x48,0x32,0xCB,0x3F,0xC2,0x06,0x71,0x92,0x3A,0xFC,0x22,0x4E,0x27,0xED,0x25,
      0x10,0xAA,0x55,0x9B,0x93,0x92,0x92,0x8A,0xF9,0xCF,0xDA,0x84,0x8A,0xFD,0xD8,0xC3,
      0xDE,0xDE,0xCF,0xC4,0x8A,0xC8,0xD3,0x8A,0xFE,0xEB,0xE1,0xEB,0xE1,0xE3,0x8A,0xE1,
      0xE5,0xE8,0xEB,0xF3,0xEB,0xF9,0xE2,0xE3,0xAA,0x68,0x08,0xE0,0x03,0x8A,0x2F,0x50,
      0x03,0x9A,0x2F,0x51,0x03,0x1C,0x2F,0x56,0x03,0x75,0x2F,0x57,0x1B,0x50,0x7B,0x56,
      0x5A,0xAB,0xCA,0x62,0x60,0x7A,0x5F,0x07,0xA7,0x9A,0x7A,0xA8,0x03,0xCA,0x2F,0xAA,
      0x25,0xAA,0xA8,0x2A,0xDC,0x8A,0x33,0x4A,0x07,0xBB,0x9A,0x5A,0xAE,0x63,0x88,0x3A,
      0xA8,0x2A,0xB6,0xD9,0xA4,0x9A,0x56,0x8A,0xA9,0xAA,0xCE,0x55,0xCE,0x50,0x03,0x92,
      0x2F,0x51,0xCE,0x52,0x03,0xA8,0x2F,0x53,0x8A,0xA3,0x4A,0x63,0xAA,0x5A,0xA8,0x2A,
      0xD6,0x03,0xBA,0x27,0x88,0x88,0x27,0x8F,0x88,0x03,0xAA,0x27,0x8A,0x88,0x03,0x92,
      0x27,0x8B,0xF6,0x71,0x16,0x89,0x88,0x03,0x93,0x27,0x8E,0x88,0x03,0xA8,0x27,0xB5,
      0x88,0x07,0xBA,0x9A,0xB2,0xC3,0xAB,0x2F,0x54,0x07,0xA5,0x9A,0xC3,0xAA,0x2F,0x57,
      0x07,0xA4,0xF9,0x75,0x06,0x56,0x03,0x55,0x2F,0x55,0x03,0xAB,0x2F,0x52,0xCE,0x50,
      0xCE,0x51,0xB4,0x12,0x98,0xD5,0x1F,0xA8,0xD5,0x02,0x00,0x71,0x75,0x04,0x2F,0x52,
      0x07,0xB8,0x9A,0x2F,0x50,0x07,0xB9,0x9A,0x2F,0xCE,0x72,0x00,0xAD,0xAA,0xB5,0xAA,
      0xEE,0xD9,0xBE,0x61,0x70,0x02,0x07,0xBD,0x9A,0x5A,0x92,0x63,0x8B,0x1A,0x9E,0xAC,
      0x12,0x55,0xAA,0x10,0x99,0xDC,0x51,0x7A,0x8F,0x45,0xAA,0x88,0xF2,0x20,0xCE,0x52,
      0xDF,0x50,0xA0,0xA0,0xA0,0x7A,0xAE,0xB1,0x73,0x26,0x52,0x2F,0x53,0x07,0xB2,0x9A,
      0x2F,0x55,0x0F,0xAA,0x83,0x2A,0x2F,0x54,0x8A,0x96,0x4A,0x75,0xAA,0xAC,0xA5,0xAA,
      0xA9,0x8A,0x20,0x4A,0x03,0x55,0xF9,0xAB,0x03,0x52,0xF9,0xA8,0x07,0xA2,0x9A,0xB2,
      0xC7,0x5F,0x55,0xF9,0xAE,0x07,0xA3,0xF7,0x33,0xA2,0x07,0xA0,0xF7,0x33,0xBA,0x07,
      0xA1,0xF7,0x33,0x8A,0x07,0xA6,0xF7,0x71,0x17,0xEA,0xD9,0xAA,0x9A,0xAB,0x8A,0xA2,
      0xAA,0x0F,0xAE,0x7A,0xA5,0xB2,0x0F,0xAD,0xC3,0xAA,0x2F,0xAD,0x0F,0xA2,0xC3,0x9A,
      0x2F,0xA2,0x2A,0x99,0xD9,0xAB,0x8A,0x64,0x20,0x03,0xAB,0x94,0x10,0xAE,0x67,0x72,
      0x15,0x53,0x03,0x55,0x6F,0xAF,0x03,0x85,0x4F,0xAC,0x3A,0xA0,0xD9,0x6A,0x86,0x4A,
      0x75,0xBF,0xAA,0xE6,0x4A,0x75,0xD9,0xAF,0x8A,0x50,0x8A,0xA8,0xAA,0x2C,0x7F,0x03,
      0x7A,0xAC,0x08,0x55,0x30,0xC6,0xAD,0x8A,0xCA,0xAA,0xFF,0xEE,0x4A,0x03,0xF5,0x03,
      0xFA,0xE9,0x8A,0xEF,0xC4,0xCD,0xC3,0xC4,0xCF,0x8A,0xBD,0xF8,0xFB,0x17,0xF3,0xF9,
      0xFE,0xEF,0xE7,0xAA,0xE9,0xC5,0xDA,0xD3,0xD8,0xC3,0xCD,0xC2,0xDE,0x8A,0xE2,0xFF,
      0xEE,0xF9,0xE5,0xE4,0x8A,0xF9,0xE5,0xEC,0xFE,0x8A,0x85,0x8A,0x90,0xFA,0x83,0x91,
      0xFA,0x7F,0x00,0x86,0xE6,0xDE,0xCE,0x84,0xAA,0x8A,0xFF,0x03,0x1F,0xAA,0xFF,0xEE,
      0x7F,0x07,0x0F,0x00,0xEE,0x00,0x00
   };

   src = disc_header;

   for (;;)
   {
      cmd = *src++;

      len = (cmd & 112) >> 4;
      if (len == 7) {
         len = *src++ + 7;
         if (len == 256) { len = src[0] + 256 * src[1]; src += 2; }
         else
         if (len == 257) { len = *src++ + 256; }
      }
      while (len--) *dst++ = 0xAAu ^ *src++;
      signed sOff = *src++ - 256;
      if (cmd & 128) {
         sOff  = (sOff ^ 65280) | (256 * *src++);
      }
      win = dst + sOff;
      len = (cmd & 15) + 3;
      if (len == 18) {
         len = *src++ + 18;
         if (len == 256) { len = src[0] + 256 * src[1]; src += 2; if (len == 0) break; }
         else
         if (len == 257) { len = *src++ + 256; }
      }
      while (len--) *dst++ = *win++;
   }

   return(dst);
}

void
init_path(void)
{
   const char *p, *pl;
   int i, l;

   strcpy(incpath[0], ".");
   strcat(incpath[0], PATH_SEPARATOR_STRING);

   p = getenv("PCE_INCLUDE");

   if (p == NULL) {
      p =
#ifdef WIN32
         "c:\\huc\\include\\pce"
#else
         "/usr/local/lib/huc/include/pce;" \
         "/usr/local/huc/include/pce;" \
         "/usr/local/share/huc/include/pce;" \
         "/usr/local/include/pce;" \
         "/usr/lib/huc/include/pce;" \
         "/usr/share/huc/include/pce;" \
         "/usr/include/pce"
#endif
      ;
   }

   for (i = 1; i < 10; i++) {
      pl = strchr(p, ';');

      if (pl == NULL)
         l = strlen(p);
      else
         l = pl - p;

      if (l) {
         strncpy(incpath[i], p, l);
         p += l;
         while (*p == ';')
            p++;
      }
      incpath[i][l] = '\0';

      if (l) {
         if (incpath[i][l - 1] != PATH_SEPARATOR)
            strcat(incpath[i], PATH_SEPARATOR_STRING);
      }
   }
}


FILE *
file_open(char *name, char *mode)
{
   FILE *fp = NULL;
   char testname[256];
   int i;

/* search current directory, then PCE_INCLUDE path */

   for (i = 0; i < 10; i++) {
      if (strlen(incpath[i])) {
         strcpy(testname, incpath[i]);
         strcat(testname, name);
         fp = fopen(testname, mode);
         if (fp != NULL) {
            if (debug) {
               printf("filename      = %s\n", testname);
            }
            break;
         }
      }
   }

   return(fp);
}


void
file_write(FILE *outfile, FILE *infile, char *filename, int curr_filenum)
{
   char buffer[2048];
   long size;
   int sectors;
   int bytes_read, bytes_written;
   int i, j;
   int code;


   code = 0;
   if (strcmp(OVERLAY_SUFFIX, &filename[strlen(filename) - 3]) == 0) {
      code = 1;
   }

   /* check size of file */

   fseek(infile, 0L, SEEK_END);
   size = ftell(infile);
   rewind(infile);


   /* get proper number of sectors if not an exact size multiple */

   sectors = size / 2048;
   if ((sectors * 2048) != size) {
      sectors++;
   }

   for (i = 0; i < sectors; i++) {
      bytes_read = fread((void *)buffer, 1, 2048, infile);

      if (bytes_read != 2048) {
         /* wrong place to get an incomplete read */

         if ( ((sectors * 2048) == size) || ((i + 1) != sectors) ) {
            printf("Error while reading file %s\n", filename);
            exit(1);
         } else {
            /* fill buffer with zeroes */

            for (j = bytes_read; j < 2048; j++) {
               buffer[j] = 0;
            }
         }
      }

      if (code == 1) {
         if (i == 0) {  /* ie. boot segment */
            /* This byte is the place where the overlay entry point */
            /* declares "I am overlay number <n>", and now running  */

            buffer[1] = curr_filenum;

            if ((cderr_flag == 1) && (curr_filenum == 1)) {
               buffer[(CDERR_OVERRIDE & 0x07FF)] = 1;
               buffer[(CDERR_OVERLAY_NUM & 0x07FF)] = cderr_ovl << 2;
            }
         } else if (i == DATA_SECTOR)   {
            for (j = 0; j < array_count; j++) {

               /* sector_array[0] is ipl.bin which is a segment    */
               /* but not an addressable one - still, it is stored */
               /* Encode this array into DATA_SEGMENT of all code  */
               /* overlays on disk, in Hu6280 addressable order    */

               buffer[j * 4]   = (sector_array[j][0]) & 255;
               buffer[j * 4 + 1] = (sector_array[j][0]) >> 8;
               buffer[j * 4 + 2] = (sector_array[j][1]) & 255;
               buffer[j * 4 + 3] = (sector_array[j][1]) >> 8;
            }
         }
      }

      bytes_written = fwrite((void *)buffer, 1, 2048, outfile);

      if (bytes_written != 2048) {
         printf("Error writing output file while processing %s\n", filename);
         exit(1);
      }
   }
}


void
ipl_write(FILE *outfile)
{
   unsigned char ipl_buffer[4096];

   /* initialize the ipl */
   prepare_ipl(ipl_buffer);

   /* prg sector base */
   ipl_buffer[0x802] = 2;

   /* nb_sectors */
   ipl_buffer[0x803] = 16;      /* Get boot segments first; up to and including */
                                /* overlay array.  The boot segments will load */
                                /* the remaining segments and relocate code if */
                                /* necessary           */

   /* loading address */
   ipl_buffer[0x804] = 0x00;
   ipl_buffer[0x805] = 0x40;

   /* starting address */
   ipl_buffer[0x806] = (BOOT_ENTRY_POINT & 0xff);       /* boot entry point */
   ipl_buffer[0x807] = (BOOT_ENTRY_POINT >> 8) & 0xff;

   /* mpr registers */
   ipl_buffer[0x808] = 0x00;
   ipl_buffer[0x809] = 0x01;
   ipl_buffer[0x80A] = 0x02;
   ipl_buffer[0x80B] = 0x03;
   ipl_buffer[0x80C] = 0x00;    /* boot loader also @ $C000 */

   /*load mode */
   ipl_buffer[0x80D] = 0x60;

   fwrite(ipl_buffer, 1, 4096, outfile);
}


void
zero_write(FILE *outfile, int sectors)
{
   char zero_buf[2048];
   int i;

   memset(zero_buf, 0, 2048);
   for (i = 0; i < sectors; i++) {
      fwrite(zero_buf, 1, 2048, outfile);
   }
}


void
usage(void)
{
   printf(ISOLINK_VERSION "\n");
   printf("\nUsage: isolink <outfile> <infile_1> <infile_2> -cderr <infile_n>. . .\n");
   printf("\n\n");
   printf("-cderr :  Indicates that the following overlay is to be used \n");
   printf("          instead of the default text message when SCD programs\n");
   printf("          are executed on plain CD systems\n\n");
   printf("          Note: this overlay must be compiled as '-cd', not '-scd'\n\n");
}


int
main(int argc, char *argv[])
{
   int i, j;
   int curr_sector, sectors, zero_fill;
   long file_len;
   FILE *infile;
   FILE *outfile;

   debug = 0;
   array_count = 0;
   curr_sector = 0;
   j = 0;

   init_path();

   /********************************************************/
   /* parse command-line                                   */
   /* if any sort of command-line options are found, abort */
   /*                                                      */
   /* otherwise, step through filenames testing them       */
   /* for existence, and creating an array which holds     */
   /* size and number of sectors                           */
   /********************************************************/
   if (argc < 2) {
      usage();
      exit(1);
   }

   for (i = 1; i < argc; i++) {
      if (argv[i][0] == '-') {
         if ((strcmp(argv[i], "-cderr") == 0) &&
             (i != 1) &&                /* not valid for first arg */
             (i < (argc - 1)) &&          /* must have filename after */
             (cderr_flag == 0)) {       /* only valid once on line */
            cderr_flag = 1;
            cderr_ovl = j;
            continue;
         } else {
            usage();
            exit(1);
         }
      }

      if (i == 1) {
         sectors = 2;
      } else {
         infile = file_open(argv[i], "rb");

         if (infile == NULL) {
            printf("Could not open file: %s\n", argv[i]);
            printf("Operation aborted\n\n");
            exit(1);
         }

         fseek(infile, 0L, SEEK_END);
         file_len = ftell(infile);
         rewind(infile);
         fclose(infile);

         sectors = (file_len / 2048);
         if ((sectors * 2048) != file_len) {
            sectors++;
         }

         if (debug) {
            printf("length = %ld\n", file_len);
            printf("start sector  = %d\n", curr_sector);
            printf("len (sectors) = %d\n", sectors);
         }
      }

      sector_array[j][0] = curr_sector;
      sector_array[j][1] = sectors;
      curr_sector += sectors;
      j++;
   }

   array_count = j;

   /* OK, let's open them for real now   */
   /* and copy them from input to output */

   outfile = fopen(argv[1], "wb");

   ipl_write(outfile);

   j = 0;
   for (i = 2; i < argc; i++) {
      if (argv[i][0] != '-') {
         j++;
         infile = file_open(argv[i], "rb");
         file_write(outfile, infile, argv[i], j);
         fclose(infile);
      }
   }

   /* pad it out to 6 seconds to comply */
   /* with CDROM specification */

   zero_fill = (6 * 75) - curr_sector;

   /* pad at least 2 seconds of trailing zeroes */

   if (zero_fill < (2 * 75))
      zero_fill = 2 * 75;

   zero_write(outfile, zero_fill);

   fclose(outfile);

   return(0);
}
