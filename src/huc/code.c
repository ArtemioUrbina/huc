/*	File code.c: 2.2 (84/08/31,10:05:13) */
/*% cc -O -c %
 *
 */

#include <stdint.h>
#include <stdio.h>
#include <time.h>
#include <string.h>

#include "defs.h"
#include "data.h"
#include "code.h"
#include "error.h"
#include "function.h"
#include "io.h"
#include "main.h"
#include "optimize.h"

/* locals */
intptr_t segment;

/* externs */
extern intptr_t arg_stack_flag;

/*
 *	print all assembler info before any code is generated
 *
 */
void gdata (void)
{
	if (segment == 1) {
		segment = 0;
		ol(".bss");
	}
}

void gtext (void)
{
	if (segment == 0) {
		segment = 1;
		ol(".code");
	}
}

void header (void)
{
	time_t today;

	outstr("; Small C HuC6280 (v0.2, 08/Nov/97)\n;\n");
	outstr("; Taken to HuC (22/Feb/00)\n;\n");
	outstr(";\n");
	outstr("; This file generated by ");
	outstr(HUC_VERSION);
	outstr("\n");
	outstr("; on ");
	time(&today);
	outstr(ctime(&today));
	outstr(";\n");
	outstr("\n");
	outstr("HUC\t= 1\n");
	/* Reserve space for further global definitions. */
	output_globdef = ftell(output);
	outstr("                                                                           ");
	nl();
}

void asmdefines (void)
{
	outstr(asmdefs);
}

void inc_startup (void)
{
	if (startup_incl == 0) {
		startup_incl = 1;

		nl();
		outstr("\t.include \"startup.asm\"\n");
		outstr("\t.data\n");
		outstr("\t.bank DATA_BANK\n\n");
		gtext();
		nl();
	}
}

/*
 *	print pseudo-op  to define a byte
 *
 */
void defbyte (void)
{
	ot(".db\t");
}

/*
 *	print pseudo-op to define storage
 *
 */
void defstorage (void)
{
	ot(".ds\t");
}

/*
 *	print pseudo-op to define a word
 *
 */
void defword (void)
{
	ot(".dw\t");
}

/*
 *	output instructions
 *
 */
void out_ins (intptr_t code, intptr_t type, intptr_t data)
{
	INS tmp;

	memset(&tmp, 0, sizeof(INS));

	tmp.code = code;
	tmp.type = type;
	tmp.data = data;
	gen_ins(&tmp);
}

void out_ins_ex (intptr_t code, intptr_t type, intptr_t data, intptr_t imm_type, intptr_t imm_data)
{
	INS tmp;

	memset(&tmp, 0, sizeof(INS));

	tmp.code = code;
	tmp.type = type;
	tmp.data = data;
	tmp.imm_type = imm_type;
	tmp.imm_data = imm_data;
	gen_ins(&tmp);
}

void out_ins_sym (intptr_t code, intptr_t type, intptr_t data, SYMBOL *sym)
{
	INS tmp;

	memset(&tmp, 0, sizeof(INS));

	tmp.code = code;
	tmp.type = type;
	tmp.data = data;
	tmp.sym = sym;
	gen_ins(&tmp);
}

void gen_ins (INS *tmp)
{
	if (optimize)
		push_ins(tmp);
	else {
		if (arg_stack_flag)
			arg_push_ins(tmp);
		else
			gen_code(tmp);
	}
}

static void out_type (intptr_t type, intptr_t data)
{
	switch (type) {
	case T_VALUE:
		outdec(data);
		break;
	case T_LABEL:
		outlabel(data);
		break;
	case T_SYMBOL:
		outsymbol((char *)data);
		break;
	case T_LITERAL:
		outstr((char *)data);
		break;
	case T_STRING:
		outlabel(litlab);
		outbyte('+');
		outdec(data);
		break;
	case T_BANK:
		outstr("BANK(");
		outstr((char *)data);
		outstr(")");
		break;
	case T_VRAM:
		outstr("VRAM(");
		outstr((char *)data);
		outstr(")");
		break;
	case T_PAL:
		outstr("PAL(");
		outstr((char *)data);
		outstr(")");
		break;
	}
}

static void out_addr (intptr_t type, intptr_t data)
{
	switch (type) {
	case T_LABEL:
		outlabel(data);
		break;
	case T_SYMBOL:
		outsymbol((char *)data);
		break;
	case T_LITERAL:
		outstr((char *)data);
		break;
	case T_PTR:
		outstr("__ptr");
		break;
	case T_VALUE:
		outdec(data);
		break;
	case T_STACK:
		outstr("__stack");
		break;
	}
}

void dump_ins (INS *tmp)
{
	FILE *save = output;

	output = stdout;
	gen_code(tmp);
	output = save;
}

/*
 *	gen assembly code
 *
 */
void gen_code (INS *tmp)
{
	intptr_t code;
	intptr_t type;
	intptr_t data;
	intptr_t imm_type;
	intptr_t imm_data;

	code = tmp->code;
	type = tmp->type;
	data = tmp->data;
	imm_type = tmp->imm_type;
	imm_data = tmp->imm_data;

	if (type == T_NOP)
		return;

	switch (code) {
	case I_FARPTR:
		ot("__farptr\t");

		switch (type) {
		case T_LABEL:
			outlabel(data);
			break;
		case T_SYMBOL:
			outsymbol((char *)data);
			break;
		}
		outstr(",");
		outstr(tmp->arg[0]);
		outstr(",");
		outstr(tmp->arg[1]);
		nl();
		break;

	case I_FARPTR_I:
		ot("__farptr_i\t");
		outsymbol((char *)data);
		outstr(",");
		outstr(tmp->arg[0]);
		outstr(",");
		outstr(tmp->arg[1]);
		nl();
		break;

	case I_FARPTR_GET:
		ot("__farptr_get\t");
		outstr(tmp->arg[0]);
		outstr(",");
		outstr(tmp->arg[1]);
		nl();
		break;

	case I_FGETB:
		ot("__farptr_i\t");
		outsymbol((char *)data);
		nl();
		ol("__fgetb");
		break;

	case I_FGETUB:
		ot("__farptr_i\t");
		outsymbol((char *)data);
		nl();
		ol("__fgetub");
		break;

	case I_FGETW:
		ot("__farptr_i\t");
		outsymbol((char *)data);
		nl();
		ol("  jsr\t_farpeekw.fast");
		break;

	case I_VGETW:
		ol("__ldw\tvideo_data");
		break;

	case I_VPUTW:
		ol("__stw\tvideo_data");
		break;

	case I_LDB:
	case I_LDBY:
		if (code == I_LDBY)
			ot("__ldby\t");
		else
			ot("__ldb\t");
		out_type(type, data);
		nl();
		break;

	case I_LDYB:
		ot("  ldy\t");
		out_type(type, data);
		nl();
		break;

	case I_LDUB:
		ot("__ldub\t");
		out_type(type, data);
		nl();
		break;

	case I_LDBP:
		ot("__ldbp\t");
		out_addr(type, data);
		nl();
		break;

	case I_LDUBP:
		ot("__ldubp\t");
		out_addr(type, data);
		nl();
		break;

	case I_STBP:
		ot("__stbp\t");
		out_addr(type, data);
		nl();
		break;

	case I_LDW:
		ot("__ldw\t");
		out_addr(type, data);
		nl();
		break;

	case I_LDWI:
		ot("__ldwi\t");
		out_type(type, data);
		nl();
		break;

	case I_LDWP:
		ot("__ldwp\t");
		out_addr(type, data);
		nl();
		break;

	case I_STWP:
		ot("__stwp\t");
		out_addr(type, data);
		nl();
		break;

	case I_STB:
		ot("  stx\t");
		out_addr(type, data);
		nl();
		break;

	case I_STBPS:
		ol("__stbps");
		break;

	case I_STW:
		ot("__stw\t");
		if (type == T_PTR)
			outstr("<");
		out_addr(type, data);
		nl();
		break;

	case I_STWI:
	case I_STBI:
		if (code == I_STWI)
			ot("__stwi\t");
		else
			ot("__stbi\t");
		out_type(type, data);
		outstr(", ");
		out_type(imm_type, imm_data);
		nl();
		break;

	case I_STWZ:
		ot("__stwz\t");
		out_type(type, data);
		nl();
		break;

	case I_STBZ:
		ot("stz\t");
		out_type(type, data);
		nl();
		break;
	case I_STWPS:
		ol("__stwps");
		break;

	case I_ADDW:
		ot("__addw\t");
		out_addr(type, data);
		nl();
		break;

	case I_ADDB:
		ot("__addb\t");
		out_addr(type, data);
		nl();
		break;

	case I_ADDUB:
		ot("__addub\t");
		out_addr(type, data);
		nl();
		break;

	case I_ADDWI:
	case I_ADDBI:
		if (code == I_ADDBI)
			ot("__addbi");
		else
			ot("__addwi");
		/* Assembler workaround; pceas doesn't like if the code
		   size changes as it resolved a symbol, so we use the
		   variant without ".if"s if there is a symbol involved. */
		if (type == T_SYMBOL ||
		    type == T_LITERAL ||
		    type == T_STRING)
			outstr("_sym");
		outstr("\t");
		out_type(type, data);
		nl();
		break;

	case I_ADDBI_P:
		ot("__addbi_p\t");
		out_type(type, data);
		nl();
		break;

	case I_ADDWS:
		ol("__addws");
		break;

	case I_ADDBS:
		ol("__addbs");
		break;

	case I_ADDMI:
		ot("__addmi");
		if (type == T_LITERAL) {
			outstr("_sym\t");
			outstr((char *)data);
		}
		else {
			outstr("\t");
			outdec(data);
		}
		outstr(",__stack");
		nl();
		break;

	case I_SUBW:
		ot("__subw\t");
		out_addr(type, data);
		nl();
		break;

	case I_SUBWI:
		ot("__subwi\t");
		outdec(data);
		nl();
		break;

	case I_SUBWS:
		ol("__subws");
		break;

	case I_ORWI:
		ot("__orwi\t");
		outdec(data);
		nl();
		break;

	case I_STBIP:
		ot("__stbip\t");
		outdec(data);
		nl();
		break;

	case I_STWIP:
		ot("__stwip\t");
		outdec(data);
		nl();
		break;

	case I_ORWS:
		ol("__orws");
		break;

	case I_EORWS:
		ol("__eorws");
		break;

	case I_ANDWI:
		ot("__andwi\t");
		outdec(data);
		nl();
		break;

	case I_ANDWS:
		ol("__andws");
		break;

	case I_ASLW:
		ol("__aslw");
		break;

	case I_ASLWI:
		ot("__aslwi\t");
		out_type(type, data);
		nl();
		break;

	case I_LSRWI:
		ot("__lsrwi\t");
		out_type(type, data);
		nl();
		break;

	case I_ASRWI:
		ot("__asrwi\t");
		out_type(type, data);
		nl();
		break;

	case I_ASLWS:
		ol("__aslws");
		break;

	case I_ASRW:
		ol("__asrw");
		break;

	case I_COMW:
		ol("__comw");
		break;

	case I_NEGW:
		ol("__negw");
		break;

	case I_SWAPW:
		ol("__swapw");
		break;

	case I_EXTW:
		ol("__extw");
		break;

	case I_BOOLW:
		ol("__boolw");
		break;

	case I_NOTW:
		ol("__notw");
		break;

	case I_JMP:
		ot("  jmp\t");
		outsymbol((char *)data);
		nl();
		break;

	case I_JSR:
		ot("  jsr\t");

		switch (type) {
		case T_SYMBOL:
			outsymbol((char *)data);
			break;
		case T_LIB:
			outstr((char *)data);
			break;
		}
		nl();
		break;

	case I_CALL:
		switch (type) {
		case T_SYMBOL:
			ot("  call\t");
			outsymbol((char *)data);
			if (imm_data) {
				outstr(".");
				outdec(imm_data);
			}
			break;
		case T_LIB:
			ot("  jsr\t");
			outstr((char *)data);
			break;
		}
		nl();
		break;

	case I_MACRO:
		switch (type) {
		case T_SYMBOL:
			ot("  \t");
			outsymbol((char *)data);
			if (imm_data) {
				outstr(".");
				outdec(imm_data);
			}
			break;
		case T_LIB:
			ot("  \t");
			outstr((char *)data);
			break;
		}
		nl();
		break;

	case I_MAPCBANK:
		ot("__map_callbank\t");
		outsymbol((char *)data);
		if (imm_data) {
			outstr(".");
			outdec(imm_data);
		}
		nl();
		break;

	case I_UNMAPCBANK:
		ot("__unmap_callbank\t");
		outsymbol((char *)data);
		if (imm_data) {
			outstr(".");
			outdec(imm_data);
		}
		nl();
		break;

	case I_CALLS:
		ot("__calls\t");
		outdec(data);
		nl();
		break;

	case I_RTS:
		ol("  rts");
		break;

	case I_PUSHW:
		ol("__pushw");
		break;

	case I_POPW:
		ol("__popw");
		break;

	case I_SAVEW:
		ol("__phax");
		break;

	case I_RESW:
		ol("__plax");
		break;

	case I_SAVEB:
		ol("phx");
		break;

	case I_RESB:
		ol("plx");
		break;

	case I_TSTW:
		ol("__tstw");
		break;

	case I_LBRA:
		ot("__lbra\t");
		outlabel(data);
		nl();
		break;

	case I_LBRAN:
		ot("__lbran\t");
		outlabel(data);
		nl();
		break;

	case I_LBEQ:
		ot("__lbeq\t");
		outlabel(data);
		nl();
		break;

	case I_LBEQN:
		ot("__lbeqn\t");
		outlabel(data);
		nl();
		break;

	case I_LBNE:
		ot("__lbne\t");
		outlabel(data);
		nl();
		break;

	case I_LBNEN:
		ot("__lbnen\t");
		outlabel(data);
		nl();
		break;

	case I_CMPWI_EQ:
		ot("__cmpwi_eq\t");
		out_type(type, data);
		nl();
		break;

	case I_CMPWI_NE:
		ot("__cmpwi_ne\t");
		out_type(type, data);
		nl();
		break;

	case I_BANK:
		ot(".bank\t");
		switch (type) {
		case T_VALUE:
			outdec(data);
			break;
		default:
			error("bank type switching not handled");
			break;
		}
		nl();
		break;

	case I_OFFSET:
		ot(".org\t");
		switch (type) {
		case T_VALUE:
			outhex((unsigned short)data);
			break;
		default:
			error("org type setting not handled");
			break;
		}
		nl();
		break;

	case I_INCW:
		ot("incw\t");
		out_addr(type, data);
		nl();
		break;

	case I_INCB:
		ot("inc\t");
		out_addr(type, data);
		nl();
		break;

	case I_LABEL:
		outlabel(data);
		col();
		nl();
		break;

	case I_MULWI:
		ot("__mulwi\t");
		outdec(data);
		nl();
		break;

	case I_EXTUW:
		ol("cla");
		break;

	case I_DEF:
		outstr((char *)data);
		outstr(" .equ ");
		outdec(imm_data);
		nl();
		break;

	case I_SEI:
		ol("sei");
		break;

	case I_CLI:
		ol("cli");
		break;

	default:
		gen_asm(tmp);
		break;
	}
}
