/*	File code.c: 2.2 (84/08/31,10:05:13) */
/*% cc -O -c %
 *
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <time.h>
#include <string.h>

#include "defs.h"
#include "data.h"
#include "code.h"
#include "error.h"
#include "function.h"
#include "io.h"
#include "main.h"
#include "optimize.h"

/* locals */
int segment;

/* externs */
extern int arg_stack_flag;

/*
 *	print all assembler info before any code is generated
 *
 */
void gdata (void)
{
	if (segment == 1) {
		segment = 0;
		ol(".bss");
	}
}

void gtext (void)
{
	if (segment == 0) {
		segment = 1;
		ol(".code");
	}
}

void header (void)
{
	time_t today;

	outstr("; Small-C HuC6280 (1997-Nov-08)\n");
	outstr("; became HuC      (2000-Feb-22)\n");
	outstr("; became HuCC     (2024-May-01)\n");
	outstr(";\n");
	outstr("; This file generated by ");
	outstr(HUC_VERSION);
	outstr("\n");
	outstr("; on ");
	time(&today);
	outstr(ctime(&today));
	outstr(";\n");
	outstr("\n");
	outstr("HUC\t\t=\t1\n");
	outstr("HUCC\t\t=\t1\n");
	/* Reserve space for further global definitions. */
	output_globdef = ftell(output);
	outstr("                                                                           ");
	nl();
}

void asmdefines (void)
{
	outstr(asmdefs);
}

void inc_startup (void)
{
	if (startup_incl == 0) {
		startup_incl = 1;

		nl();
		outstr("\t\tinclude\t\"hucc.asm\"\n");
		outstr("\t\t.data\n");
		outstr("\t\t.bank\tDATA_BANK\n\n");
		gtext();
		nl();
	}
}

/*
 *	print pseudo-op  to define a byte
 *
 */
void defbyte (void)
{
	ot(".db\t\t");
}

/*
 *	print pseudo-op to define storage
 *
 */
void defstorage (void)
{
	ot(".ds\t\t");
}

/*
 *	print pseudo-op to define a word
 *
 */
void defword (void)
{
	ot(".dw\t\t");
}

/*
 *	output instructions
 *
 */
void out_ins (int code, int type, intptr_t data)
{
	INS tmp;

	memset(&tmp, 0, sizeof(INS));

	tmp.code = code;
	tmp.type = type;
	tmp.data = data;
	gen_ins(&tmp);
}

void out_ins_ex (int code, int type, intptr_t data, int imm_type, intptr_t imm_data)
{
	INS tmp;

	memset(&tmp, 0, sizeof(INS));

	tmp.code = code;
	tmp.type = type;
	tmp.data = data;
	tmp.imm_type = imm_type;
	tmp.imm_data = imm_data;
	gen_ins(&tmp);
}

void out_ins_sym (int code, int type, intptr_t data, SYMBOL *sym)
{
	INS tmp;

	memset(&tmp, 0, sizeof(INS));

	tmp.code = code;
	tmp.type = type;
	tmp.data = data;
	tmp.sym = sym;
	gen_ins(&tmp);
}

void gen_ins (INS *tmp)
{
	if (optimize)
		push_ins(tmp);
	else {
		if (arg_stack_flag)
			arg_push_ins(tmp);
		else
			gen_code(tmp);
	}
}

static void out_type (int type, intptr_t data)
{
	switch (type) {
	case T_VALUE:
		outdec((int)data);
		break;
	case T_LABEL:
		outlabel((int)data);
		break;
	case T_SYMBOL:
		outsymbol((SYMBOL *)data);
		break;
	case T_LITERAL:
		outstr((const char *)data);
		break;
	case T_STRING:
		outconst(litlab);
		outbyte('+');
		outdec((int)data);
		break;
	case T_BANK:
		outstr("BANK(");
		outstr((const char *)data);
		outstr(")");
		break;
	case T_VRAM:
		outstr("VRAM(");
		outstr((const char *)data);
		outstr(")");
		break;
	case T_PAL:
		outstr("PAL(");
		outstr((const char *)data);
		outstr(")");
		break;
	}
}

static void out_addr (int type, intptr_t data)
{
	switch (type) {
	case T_LABEL:
		outlabel((int)data);
		break;
	case T_SYMBOL:
		outsymbol((SYMBOL *)data);
		break;
	case T_LITERAL:
		outstr((const char *)data);
		break;
	case T_PTR:
		outstr("__ptr");
		break;
	case T_VALUE:
		outdec((int)data);
		break;
	case T_STACK:
		outstr("__stack");
		break;
	}
}

void dump_ins (INS *tmp)
{
	FILE *save = output;

	output = stdout;
	gen_code(tmp);
	output = save;
}

/*
 *	gen assembly code
 *
 */
void gen_code (INS *tmp)
{
	enum ICODE code;
	int type;
	intptr_t data;
	int imm_type;
	intptr_t imm_data;

	code = tmp->code;
	type = tmp->type;
	data = tmp->data;
	imm_type = tmp->imm_type;
	imm_data = tmp->imm_data;

	if (type == T_NOP)
		return;

	switch (code) {

	/* i-code that retires the primary register contents */

	case I_FENCE:
		ot("__fence");
		nl();
		break;

	/* i-codes for handling farptr */

	case I_FARPTR:
		ot("__farptr\t");

		switch (type) {
		case T_LABEL:
			outlabel((int)data);
			break;
		case T_SYMBOL:
			outsymbol((SYMBOL *)data);
			break;
		case T_STRING:
			outconst(litlab);
			outbyte('+');
			outdec((int)data);
			break;
		}
		outstr(", ");
		outstr(tmp->arg[0]);
		outstr(", ");
		outstr(tmp->arg[1]);
		nl();
		break;

	case I_FARPTR_I:
		ot("__farptr_i\t");
		outsymbol((SYMBOL *)data);
		outstr(", ");
		outstr(tmp->arg[0]);
		outstr(", ");
		outstr(tmp->arg[1]);
		nl();
		break;

	case I_FARPTR_GET:
		ot("__farptr_get\t");
		outstr(tmp->arg[0]);
		outstr(", ");
		outstr(tmp->arg[1]);
		nl();
		break;

	case I_FGETW:
		ot("__farptr_i\t");
		outsymbol((SYMBOL *)data);
		nl();
		ol("  jsr\t_farpeekw.fast");
		break;

	case I_FGETB:
		ot("__farptr_i\t");
		outsymbol((SYMBOL *)data);
		nl();
		ol("__fgetb");
		break;

	case I_FGETUB:
		ot("__farptr_i\t");
		outsymbol((SYMBOL *)data);
		nl();
		ol("__fgetub");
		break;

	/* i-codes for interrupts */

	case I_SEI:
		ol("sei");
		break;

	case I_CLI:
		ol("cli");
		break;

	/* i-codes for calling functions */

	case I_MACRO:
		/* because functions don't need to be pre-declared
		   in HuC we get a string and not a symbol */
		switch (type) {
		case T_LITERAL:
			ot(" ");
			prefix();
			outstr((const char *)data);
			if (imm_data) {
				outstr(".");
				outdec((int)imm_data);
			}
			break;
		}
		nl();
		break;

	case I_CALL:
		/* because functions don't need to be pre-declared
		   in HuC we get a string and not a symbol */
		switch (type) {
		case T_LITERAL:
			ot("  call\t\t");
			prefix();
			outstr((const char *)data);
			if (imm_data) {
				outstr(".");
				outdec((int)imm_data);
			}
			break;
		}
		nl();
		break;

	case I_CALLP:
		ol("__callp");
		break;

	case I_JSR:
		ot("  jsr\t\t");

		switch (type) {
		case T_SYMBOL:
			outsymbol((SYMBOL *)data);
			break;
		case T_LIB:
			outstr((const char *)data);
			break;
		}
		nl();
		break;

	/* i-codes for C functions and the C parameter stack */

	case I_ENTER:
		ot("__enter\t\t");
		outsymbol((SYMBOL *)data);
		nl();
		break;

	case I_LEAVE:
		ot("__leave\t\t");
		outdec((int)data);
		nl();
		break;

	case I_GETACC:
		ol("__getacc");
		break;

	case I_SAVESP:
		ol("__savesp");
		break;

	case I_LOADSP:
		ol("__loadsp");
		break;

	case I_MODSP:
		ot("__modsp");
		if (type == T_LITERAL) {
			outstr("_sym\t");
			outstr((const char *)data);
		}
		else {
			outstr("\t\t");
			outdec((int)data);
		}
		nl();
		break;

	case I_PUSHW:
		ol("__pushw");
		break;

	case I_POPW:
		ol("__popw");
		break;

	case I_SPUSHW:
		ol("__spushw");
		break;

	case I_SPOPW:
		ol("__spopw");
		break;

	case I_SPUSHB:
		ol("__spushb");
		break;

	case I_SPOPB:
		ol("__spopb");
		break;

	/* i-codes for handling boolean tests and branching */

	case I_SWITCHW:
		ot("__switchw\t");
		outlabel((int)data);
		nl();
		break;

	case I_SWITCHB:
		ot("__switchb\t");
		outlabel((int)data);
		nl();
		break;

	case I_CASE:
		ot("__case\t\t");
		if (type == T_VALUE)
			outdec((int)data);
		nl();
		break;

	case I_ENDCASE:
		ot("__endcase");
		nl();
		break;

	case I_LABEL:
		outlabel((int)data);
		col();
		break;

	case I_ALIAS:
		outlabel((int)data);
		ot(".alias\t\t");
		outlabel((int)imm_data);
		nl();
		break;

	case I_BRA:
		ot("__bra\t\t");
		outlabel((int)data);
		nl();
		break;

	case I_DEF:
		outstr((const char *)data);
		outstr(" .equ ");
		outdec((int)imm_data);
		nl();
		break;

	case I_CMPW:
		ot("__cmpw\t\t");

		switch (type) {
		case T_SYMBOL:
			outsymbol((SYMBOL *)data);
			break;
		case T_LIB:
			outstr((const char *)data);
			break;
		}
		nl();
		break;

	case I_CMPB:
		ot("__cmpb\t\t");

		switch (type) {
		case T_SYMBOL:
			outsymbol((SYMBOL *)data);
			break;
		case T_LIB:
			outstr((const char *)data);
			break;
		}
		nl();
		break;

	case X_CMPWI_EQ:
		ot("__cmpwi_eq\t");
		out_type(type, data);
		nl();
		break;

	case X_CMPWI_NE:
		ot("__cmpwi_ne\t");
		out_type(type, data);
		nl();
		break;

	case I_TSTW:
		ol("__tstw");
		break;

	case I_NOTW:
		ol("__notw");
		break;

	case I_BFALSE:
		ot("__bfalse\t");
		outlabel((int)data);
		nl();
		nl();
		break;

	case I_BTRUE:
		ot("__btrue\t\t");
		outlabel((int)data);
		nl();
		nl();
		break;

	case X_TZW:
		ot("__tzw\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_TZWP:
		ot("__tzwp\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_TZW_S:
		ot("__tzw_s\t\t");
		outdec((int)data);
		nl();
		break;

	case X_TZB:
		ot("__tzb\t\t");
		out_type(type, data);
		nl();
		break;

	case X_TZBP:
		ot("__tzbp\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_TZB_S:
		ot("__tzb_s\t\t");
		outdec((int)data);
		nl();
		break;

	case X_TNZW:
		ot("__tnzw\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_TNZWP:
		ot("__tnzwp\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_TNZW_S:
		ot("__tnzw_s\t");
		outdec((int)data);
		nl();
		break;

	case X_TNZB:
		ot("__tnzb\t\t");
		out_type(type, data);
		nl();
		break;

	case X_TNZBP:
		ot("__tnzbp\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_TNZB_S:
		ot("__tnzb_s\t");
		outdec((int)data);
		nl();
		break;

	/* i-codes for loading the primary register */

	case I_LDWI:
		ot("__ldwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_LEA_S:
		ot("__lea_s\t\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case I_LDW:
		ot("__ldw\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_LDB:
		ot("__ldb\t\t");
		out_type(type, data);
		nl();
		break;

	case I_LDUB:
		ot("__ldub\t\t");
		out_type(type, data);
		nl();
		break;

	case I_LDWP:
		ot("__ldwp\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_LDBP:
		ot("__ldbp\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_LDUBP:
		ot("__ldubp\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_LD_WAR:
		ot("__ld.war\t");
		out_type(type, data);
		nl();
		break;

	case X_LD_BAR:
		ot("__ld.bar\t");
		out_type(type, data);
		nl();
		break;

	case X_LD_CAR:
		ot("__ld.car\t");
		out_type(type, data);
		nl();
		break;

	case X_LDW_S:
		ot("__ldw_s\t\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDB_S:
		ot("__ldb_s\t\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDUB_S:
		ot("__ldub_s\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDP_WAR:
		ot("__ldp.war\t");
		out_type(type, data);
		nl();
		break;

	case X_LDP_BAR:
		ot("__ldp.bar\t");
		out_type(type, data);
		nl();
		break;

	case X_LDP_CAR:
		ot("__ldp.car\t");
		out_type(type, data);
		nl();
		break;

//	case X_LDWA_S:
//		ot("__ldwa_s\t");
//		outsymbol((SYMBOL *)imm_data);
//		outstr(", ");
//		outdec((int)data);
//		outlocal(tmp->sym);
//		nl();
//		break;
//
//	case X_LDBA_S:
//		ot("__ldba_s\t");
//		outsymbol((SYMBOL *)imm_data);
//		outstr(", ");
//		outdec((int)data);
//		outlocal(tmp->sym);
//		nl();
//		break;
//
//	case X_LDUBA_S:
//		ot("__lduba_s\t");
//		outsymbol((SYMBOL *)imm_data);
//		outstr(", ");
//		outdec((int)data);
//		outlocal(tmp->sym);
//		nl();
//		break;

	/* i-codes for pre- and post- increment and decrement */

	case X_INCLD_WM:
		ot("__incld.wm\t");
		out_type(type, data);
		nl();
		break;

	case X_INCLD_BM:
		ot("__incld.bm\t");
		out_type(type, data);
		nl();
		break;

	case X_INCLD_CM:
		ot("__incld.cm\t");
		out_type(type, data);
		nl();
		break;

	case X_DECLD_WM:
		ot("__decld.wm\t");
		out_type(type, data);
		nl();
		break;

	case X_DECLD_BM:
		ot("__decld.bm\t");
		out_type(type, data);
		nl();
		break;

	case X_DECLD_CM:
		ot("__decld.cm\t");
		out_type(type, data);
		nl();
		break;

	case X_LDINC_WM:
		ot("__ldinc.wm\t");
		out_type(type, data);
		nl();
		break;

	case X_LDINC_BM:
		ot("__ldinc.bm\t");
		out_type(type, data);
		nl();
		break;

	case X_LDINC_CM:
		ot("__ldinc.cm\t");
		out_type(type, data);
		nl();
		break;

	case X_LDDEC_WM:
		ot("__lddec.wm\t");
		out_type(type, data);
		nl();
		break;

	case X_LDDEC_BM:
		ot("__lddec.bm\t");
		out_type(type, data);
		nl();
		break;

	case X_LDDEC_CM:
		ot("__lddec.cm\t");
		out_type(type, data);
		nl();
		break;

	case X_INC_WMQ:
		ot("__inc.wmq\t");
		out_type(type, data);
		nl();
		break;

	case X_INC_CMQ:
		ot("__inc.cmq\t");
		out_type(type, data);
		nl();
		break;

	case X_DEC_WMQ:
		ot("__dec.wmq\t");
		out_type(type, data);
		nl();
		break;

	case X_DEC_CMQ:
		ot("__dec.cmq\t");
		out_type(type, data);
		nl();
		break;

	case X_INCLD_WS:
		ot("__incld.ws\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_INCLD_BS:
		ot("__incld.bs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_INCLD_CS:
		ot("__incld.cs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_DECLD_WS:
		ot("__decld.ws\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_DECLD_BS:
		ot("__decld.bs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_DECLD_CS:
		ot("__decld.cs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDINC_WS:
		ot("__ldinc.ws\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDINC_BS:
		ot("__ldinc.bs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDINC_CS:
		ot("__ldinc.cs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDDEC_WS:
		ot("__lddec.ws\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDDEC_BS:
		ot("__lddec.bs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_LDDEC_CS:
		ot("__lddec.cs\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_INC_WSQ:
		ot("__inc.wsq\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_INC_CSQ:
		ot("__inc.csq\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_DEC_WSQ:
		ot("__dec.wsq\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_DEC_CSQ:
		ot("__dec.csq\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_INCLD_WAR:
		ot("__incld.war\t");
		out_type(type, data);
		nl();
		break;

	case X_INCLD_BAR:
		ot("__incld.bar\t");
		out_type(type, data);
		nl();
		break;

	case X_INCLD_CAR:
		ot("__incld.car\t");
		out_type(type, data);
		nl();
		break;

	case X_DECLD_WAR:
		ot("__decld.war\t");
		out_type(type, data);
		nl();
		break;

	case X_DECLD_BAR:
		ot("__decld.bar\t");
		out_type(type, data);
		nl();
		break;

	case X_DECLD_CAR:
		ot("__decld.car\t");
		out_type(type, data);
		nl();
		break;

	case X_LDINC_WAR:
		ot("__ldinc.war\t");
		out_type(type, data);
		nl();
		break;

	case X_LDINC_BAR:
		ot("__ldinc.bar\t");
		out_type(type, data);
		nl();
		break;

	case X_LDINC_CAR:
		ot("__ldinc.car\t");
		out_type(type, data);
		nl();
		break;

	case X_LDDEC_WAR:
		ot("__lddec.war\t");
		out_type(type, data);
		nl();
		break;

	case X_LDDEC_BAR:
		ot("__lddec.bar\t");
		out_type(type, data);
		nl();
		break;

	case X_LDDEC_CAR:
		ot("__lddec.car\t");
		out_type(type, data);
		nl();
		break;

	case X_INC_WARQ:
		ot("__inc.warq\t");
		out_type(type, data);
		nl();
		break;

	case X_INC_CARQ:
		ot("__inc.carq\t");
		out_type(type, data);
		nl();
		break;

	case X_DEC_WARQ:
		ot("__dec.warq\t");
		out_type(type, data);
		nl();
		break;

	case X_DEC_CARQ:
		ot("__dec.carq\t");
		out_type(type, data);
		nl();
		break;

	/* i-codes for saving the primary register */

	case I_STWZ:
		ot("__stwz\t\t");
		out_type(type, data);
		nl();
		break;

	case I_STBZ:
		ot("__stbz\t\t");
		out_type(type, data);
		nl();
		break;

	case I_STWI:
		ot("__stwi\t\t");
		out_type(type, data);
		outstr(", ");
		out_type(imm_type, imm_data);
		nl();
		break;

	case I_STBI:
		ot("__stbi\t\t");
		out_type(type, data);
		outstr(", ");
		out_type(imm_type, imm_data);
		nl();
		break;

	case I_STWIP:
		ot("__stwip\t\t");
		outdec((int)data);
		nl();
		break;

	case I_STBIP:
		ot("__stbip\t\t");
		outdec((int)data);
		nl();
		break;

	case I_STW:
		ot("__stw\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_STB:
		ot("__stb\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_STWP:
		ot("__stwp\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_STBP:
		ot("__stbp\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_STWPS:
		ol("__stwps");
		break;

	case I_STBPS:
		ol("__stbps");
		break;

	case X_STWI_S:
		ot("__stwi_s\t");
		outdec((int)imm_data);
		outstr(", ");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_STBI_S:
		ot("__stbi_s\t");
		outdec((int)imm_data);
		outstr(", ");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_STW_S:
		ot("__stw_s\t\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_STB_S:
		ot("__stb_s\t\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_INDEX_WR:
		ot("__index.wr\t");
		out_type(type, data);
		nl();
		break;

	case X_INDEX_CR:
		ot("__index.cr\t");
		out_type(type, data);
		nl();
		break;

	case X_ST_WAT:
		ot("__st.wat\t");
		out_type(type, data);
		nl();
		break;

	case X_ST_CAT:
		ot("__st.cat\t");
		out_type(type, data);
		nl();
		break;

//	case X_STWA_S:
//		ot("__stwa_s\t");
//		outsymbol((SYMBOL *)imm_data);
//		outstr(", ");
//		outdec((int)data);
//		nl();
//		break;
//
//	case X_STBA_S:
//		ot("__stba_s\t");
//		outsymbol((SYMBOL *)imm_data);
//		outstr(", ");
//		outdec((int)data);
//		nl();
//		break;

	/* i-codes for extending a byte to a word */

	case I_EXTW:
		ol("__extw");
		break;

	case I_EXTUW:
		ol("__extuw");
		break;

	/* i-codes for math with the primary register  */

	case I_COMW:
		ol("__comw");
		break;

	case I_NEGW:
		ol("__negw");
		break;

	case I_ADDWS:
		ol("__addws");
		break;

	case I_ADDWI:
		ot("__addwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_ADDW:
		ot("__addw\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_ADDUB:
		ot("__addub\t\t");
		out_addr(type, data);
		nl();
		break;

	case X_ADDW_S:
		ot("__addw_s\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case X_ADDUB_S:
		ot("__addub_s\t");
		outdec((int)data);
		outlocal(tmp->sym);
		nl();
		break;

	case I_ADDBI_P:
		ot("__addbi_p\t");
		out_type(type, data);
		nl();
		break;

	case I_SUBWS:
		ol("__subws");
		break;

	case I_SUBWI:
		ot("__subwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_SUBW:
		ot("__subw\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_SUBUB:
		ot("__subub\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_ISUBWI:
		ot("__isubwi\t");
		out_type(type, data);
		nl();
		break;

	case I_ANDWS:
		ol("__andws");
		break;

	case I_ANDWI:
		ot("__andwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_ANDW:
		ot("__andw\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_ANDUB:
		ot("__andub\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_EORWS:
		ol("__eorws");
		break;

	case I_EORWI:
		ot("__eorwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_EORW:
		ot("__eorw\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_EORUB:
		ot("__eorub\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_ORWS:
		ol("__orws");
		break;

	case I_ORWI:
		ot("__orwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_ORW:
		ot("__orw\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_ORUB:
		ot("__orub\t\t");
		out_addr(type, data);
		nl();
		break;

	case I_ASLWS:
		ol("__aslws");
		break;

	case I_ASLWI:
		ot("__aslwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_ASLW:
		ol("__aslw");
		break;

	case I_ASRWI:
		ot("__asrwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_ASRW:
		ol("__asrw");
		break;

	case I_LSRWI:
		ot("__lsrwi\t\t");
		out_type(type, data);
		nl();
		break;

	case I_MULWI:
		ot("__mulwi\t\t");
		outdec((int)data);
		nl();
		break;

	default:
		gen_asm(tmp);
		break;
	}
}

/* ----
 * gen_asm()
 * ----
 * generate optimizer asm code
 *
 */
void gen_asm (INS *inst)
{
//	int type = inst->type;
//	intptr_t data = inst->data;

	/* i-codes for 32-bit longs */

	switch (inst->code) {

	case X_LDD_I:
		ot("__ldd_i\t\t");
		outdec((int)inst->data);
		outstr(", ");
		prefix();
		outstr(inst->arg[0]);
		outstr(", ");
		prefix();
		outstr(inst->arg[1]);
		nl();
		break;

	case X_LDD_W:
		ot("__ldd_w\t\t");
		outsymbol((SYMBOL *)inst->data);
		outstr(", ");
		prefix();
		outstr(inst->arg[0]);
		outstr(", ");
		prefix();
		outstr(inst->arg[1]);
		nl();
		break;

	case X_LDD_B:
		ot("__ldd_b\t\t");
		outsymbol((SYMBOL *)inst->data);
		outstr(", ");
		prefix();
		outstr(inst->arg[0]);
		outstr(", ");
		prefix();
		outstr(inst->arg[1]);
		nl();
		break;

	case X_LDD_S_W:
		ot("__ldd_s_w\t");
		outdec((int)inst->data);
		outstr(", ");
		prefix();
		outstr(inst->arg[0]);
		outstr(", ");
		prefix();
		outstr(inst->arg[1]);
		nl();
		break;

	case X_LDD_S_B:
		ot("__ldd_s_b\t");
		outdec((int)inst->data);
		outstr(", ");
		prefix();
		outstr(inst->arg[0]);
		outstr(", ");
		prefix();
		outstr(inst->arg[1]);
		nl();
		break;

	default:
		error("internal error: invalid instruction");
		break;
	}
}
