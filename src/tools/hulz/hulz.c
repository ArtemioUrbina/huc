// **************************************************************************
// **************************************************************************
//
// HULZ.C
//
// Simple compressor for some LZSS-derived schemes found on the PC Engine.
//
// Copyright John Brandwood 2014-2024.
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//
// **************************************************************************
// **************************************************************************

#include "elmer.h"

//
// DEFINITIONS
//

#ifndef GIT_VERSION
  #define GIT_VERSION "unknown"
#endif

#ifndef GIT_DATE
  #define GIT_DATE __DATE__
#endif

#define VERSION_STR "hulz (" GIT_VERSION ", " GIT_DATE ")"

// Which compressor has been chosen?

typedef uint8_t * (*compressor) (
  uint8_t * pSrcBuffer,
  unsigned  uSrcLength,
  uint8_t * pDstBuffer,
  unsigned  uDstLength );

compressor    g_pCompressorFunc = NULL;
compressor    g_pDecompressFunc = NULL;

//

bool          g_fDecompress = false;
bool          g_fLazyMatch  = true;

uint8_t *     g_pOutBuffer;
unsigned      g_uOutLength;

int           g_iWindowFix;



// **************************************************************************
// **************************************************************************
//
// BitInit ()
// BitWriteHiLo ()
// BitWriteLoHi ()
//
// Bit-oriented buffered output to global g_pOutBuffer.
//

unsigned    g_uOutMask;
uint8_t *   g_pOutBits = NULL;

void BitInit ( void )
{
  g_pOutBits = NULL;
}

void BitWriteHiLo ( unsigned uBitValue )
{
  if (g_pOutBits == NULL) {
    g_uOutMask = 0x80;
    g_pOutBits = g_pOutBuffer;
    *g_pOutBuffer++ = 0;
  }

  if (uBitValue & 1) {
    *g_pOutBits |= g_uOutMask;
  }

  g_uOutMask >>= 1;

  if (g_uOutMask == 0) {
    g_pOutBits = NULL;
  }
}

void BitWriteLoHi ( unsigned uBitValue )
{
  if (g_pOutBits == NULL) {
    g_uOutMask = 0x01;
    g_pOutBits = g_pOutBuffer;
    *g_pOutBuffer++ = 0;
  }

  if (uBitValue & 1) {
    *g_pOutBits |= g_uOutMask;
  }

  g_uOutMask <<= 1;

  if (g_uOutMask == 256) {
    g_pOutBits = NULL;
  }
}



// **************************************************************************
// **************************************************************************
//
// NibbleInit ()
// NibbleWriteHiLo ()
//
// Nibble-oriented buffered output to global g_pOutBuffer.
//

uint8_t *   g_pNibble = NULL;

void NibbleInit ( void )
{
  g_pNibble = NULL;
}

void NibbleWriteHiLo ( unsigned uValue )
{
  if (g_pNibble == NULL)
  {
    g_pNibble = g_pOutBuffer++;

    *g_pNibble = (uValue & 15) << 4;
  } else {
    *g_pNibble = (uValue & 15) | *g_pNibble;

    g_pNibble = NULL;
  }
}



// **************************************************************************
// **************************************************************************
//
// InitStringMatch ()
//
// Simple hash-based string search for Lempel-Ziv compression.
//
// HASH_WIN_SIZE is the size of the hash window used to track previous string
// occurrences, do not confuse it with the iMaxLzssDelta used to search for a
// current match!
//
// HASH_WIN_SIZE must be a power-of-two that is >= the largest iMaxLzssDelta.
//
// There is no harm to having a HASH_WIN_SIZE > iMaxLzssDelta, it just takes
// up more memory during compression.
//

#define HASH_VAL_SIZE 16384
#define CALC_HASH( iSrcOffset ) ((pSrcBuffer[ iSrcOffset + 0 ] & 0x7F) + 128 * (pSrcBuffer[ iSrcOffset + 1 ] & 0x7F))

#define HASH_WIN_SIZE 0x2000 // Use a default 8KB tracking window on the PC Engine.
#define HASH_WIN_MASK (HASH_WIN_SIZE - 1)

// Array of the most recent source-offset for every possible hash value.

int * g_pHashOffset;

// Array of previous source-offset with the same hash value for every window location
// in the tracking window.

int * g_pPrevOffset;

//

void InitStringMatch ( void )
{
  int i;

  if (g_pHashOffset == NULL) {
    g_pHashOffset = (int *) malloc( sizeof(int) * (HASH_VAL_SIZE + HASH_WIN_SIZE) );
    g_pPrevOffset = g_pHashOffset + HASH_VAL_SIZE;
  }

  // Initialize the hash table.

  for (i = 0; i < HASH_VAL_SIZE; ++i) {
    g_pHashOffset[i] = - 1;
  }
}



// **************************************************************************
// **************************************************************************
//
// FindStringMatch ()
//
// Simple hash-based string search for Lempel-Ziv compression.
//
// HASH_WIN_SIZE is the size of the hash window used to track previous string
// occurrences, do not confuse it with the iMaxLzssDelta used to search for a
// current match!
//
// HASH_WIN_SIZE must be a power-of-two that is >= the largest iMaxLzssDelta.
//
// There is no harm to having a HASH_WIN_SIZE > iMaxLzssDelta, it just takes
// up more memory during compression.
//

void __inline FindStringMatch (
  int * pFoundOffset, int * pFoundLength,
  const uint8_t * pSrcBuffer, const int iSrcLength,
  int iFromOffset, int iMaxLzssDelta, int iMaxLzssLength )

{
  // Local Variables.

  int iMinOffset  = ((iFromOffset - iMaxLzssDelta) < 0) ? 0 : (iFromOffset - iMaxLzssDelta);
  int iBestOffset = iMinOffset;
  int iBestLength = 0;
  int iTestOffset = g_pHashOffset[ CALC_HASH( iFromOffset ) ];
  int iTestLength;

  // Don't read beyond the pSrcBuffer.

  iMaxLzssLength = ((iSrcLength - iFromOffset) < iMaxLzssLength) ? (iSrcLength - iFromOffset) : iMaxLzssLength;

  // Stop searching when the test string is outside the iMaxLzssDelta window.

  while (iTestOffset >= iMinOffset)
  {
    // Quickly reject strings that won't be longer than the current-best.

    if (pSrcBuffer[ iFromOffset + iBestLength ] == pSrcBuffer[ iTestOffset + iBestLength ])
    {
      iTestLength = 0;

      while ((iTestLength < iMaxLzssLength) &&
        (pSrcBuffer[ iFromOffset + iTestLength ] == pSrcBuffer[ iTestOffset + iTestLength ])) {
        ++iTestLength;
      }

      if (iTestLength > iBestLength) {
        iBestOffset = iTestOffset;
        iBestLength = iTestLength;
        if (iBestLength == iMaxLzssLength) break;
      }
    }

    // Test the previous string with the same CALC_HASH() value.

    iTestOffset = g_pPrevOffset[ iTestOffset & HASH_WIN_MASK ];
  }

  *pFoundOffset = iBestOffset;
  *pFoundLength = iBestLength;
}



// **************************************************************************
// **************************************************************************
//
// CompressHLZ ()
//
// Compress data in Hudson's 4-bit length, 8-bit offset LZSS.
//
// The window offset is stored as relative to the start of the data, and not
// as a delta from the current output, but some games start decompressing to
// their 256 byte ring-buffer at $xxEF intead of $xx00, and so an offset has
// to be added to the window address that is written.
//
// With a window start of $EF, this method is used by (at least) ...
//  Tengai Makyo II - Manji Maru
//  Dragon Slayer - The Legend of Heroes II
//  Emerald Dragon
//  Linda3
//
// With a window start of $00, this method is used by (at least) ...
//  Ys IV - The Dawn of Ys
//  Gulliver Boy
//
// The bit buffer is stored hi-lo.
// The nibble buffer is stored hi-lo.
//
// Ys4 and Gulliver add a 1-byte header to signal whether the compressed data
// is encoded in byte (0) or word (1) format.
//
// This compressor does NOT handle Ys4's word format scheme!
//

uint8_t * CompressHLZ (
  uint8_t * pSrcBuffer, unsigned uSrcLength,
  uint8_t * pDstBuffer, unsigned uDstLength )

{
  // Local Variables.

  int iSrcOffset = 0;
  int iCopyCount = 0;
  int iSkipCount;

  int iHashValue;
  int iSrcRemain;
  int iBestOffset = 0;
  int iBestLength;
  int iNextOffset;
  int iNextLength;

  // Set the search parameters for this particular LZSS-variant.

  const int iMinMatch = 2;
  const int iMaxMatch = 17;
  const int iMaxDelta = 256;

  // Initialize the hash table and window for string matching.

  InitStringMatch();

  // Initialize the output.

  g_pOutBuffer = pDstBuffer;
  g_uOutLength = uDstLength;

  BitInit();
  NibbleInit();

  // Write a header to signal Ys4's BYTE compression if using Ys4's g_iWindowFix.

  if (g_iWindowFix == 0) {
    *g_pOutBuffer++ = 0;
  }

  // Loop around encoding strings until the buffer is empty.

  for (;;)
  {
    // Update the window and calc how much data is left to compress.

    iSrcRemain = uSrcLength - iSrcOffset;

    if (iSrcRemain < iMinMatch) {
      iSrcOffset += iSrcRemain;
      iCopyCount += iSrcRemain;
      break;
    }

    // Find the best match at the current position.

    iBestLength = 0;

    if (iSrcOffset != 0) {
      FindStringMatch( &iBestOffset, &iBestLength, pSrcBuffer, uSrcLength, iSrcOffset, iMaxDelta, iMaxMatch );
    }

    // Move the window on by 1 byte.

    iHashValue = CALC_HASH( iSrcOffset );

    g_pPrevOffset[ iSrcOffset & HASH_WIN_MASK ] = g_pHashOffset[ iHashValue ];
    g_pHashOffset[ iHashValue ] = iSrcOffset;

    // Lazy match (compresses up to 1% better on a good day, usually less).
    //
    // Basically, if you can compress 1 extra byte, then that is a better thing
    // to do instead of encoding 2 literals after the current match.

    if (g_fLazyMatch)
    {
      if ((iBestLength >= iMinMatch) && (iBestLength < iMaxMatch) && (iSrcRemain != iMinMatch))
      {
        FindStringMatch( &iNextOffset, &iNextLength, pSrcBuffer, uSrcLength, iSrcOffset + 1, iMaxDelta, iMaxMatch );

        if (iNextLength > iBestLength) {
          ++iCopyCount;
          ++iSrcOffset;
          iBestLength = iNextLength;
          iBestOffset = iNextOffset;
        }
      }
    }

    // Keep track of COPY bytes, but don't process them, yet.

    if (iBestLength < iMinMatch) {
      ++iCopyCount;
      ++iSrcOffset;
      continue;
    }

    // First, write any COPY bytes.

    if (iCopyCount)
    {
      uint8_t * pCopyFrom = pSrcBuffer + iSrcOffset - iCopyCount;

      do {
        // Signal that COPY is next.

        BitWriteHiLo( 1 );

        *g_pOutBuffer++ = *pCopyFrom++;
      } while (--iCopyCount);
    }

    // Then write the LZSS "match".
    //
    // Signal that LZSS is next.

    BitWriteHiLo( 0 );

    // Save LZSS offset (as an absolute window offset).

    *g_pOutBuffer++ = (iBestOffset + g_iWindowFix) & 255;

    // Save LZSS length - 2.

    NibbleWriteHiLo( iBestLength - 2 );

    // Skip passed "matched" bytes, updating the window contents.

    ++iSrcOffset;

    iSkipCount = iBestLength - 1;

    while (iSkipCount--)
    {
      iHashValue = CALC_HASH( iSrcOffset );

      g_pPrevOffset[ iSrcOffset & HASH_WIN_MASK ] = g_pHashOffset[ iHashValue ];
      g_pHashOffset[ iHashValue ] = iSrcOffset;

      ++iSrcOffset;
    }

  } // End of "for (;;)"

  // Encode the last COPY byte(s) (if there are any).

  if (iCopyCount)
  {
    uint8_t * pCopyFrom = pSrcBuffer + iSrcOffset - iCopyCount;

    do {
      // Signal that COPY is next.

      BitWriteHiLo( 1 );

      *g_pOutBuffer++ = *pCopyFrom++;
    } while (--iCopyCount);
  }

  // All done.

  return (g_pOutBuffer);
}



// **************************************************************************
// **************************************************************************
//
// DecompressHLZ ()
//
// Decompress data in Hudson's 4-bit length, 8-bit offset LZSS.
//
// The window offset is stored as relative to the start of the data, and not
// as a delta from the current output, but some games start decompressing to
// their 256 byte ring-buffer at $xxEF intead of $xx00.
//
// With a window start of $EF, this method is used by (at least) ...
//  Tengai Makyo II - Manji Maru
//  Dragon Slayer - The Legend of Heroes II
//  Emerald Dragon
//  Linda3
//
// With a window start of $00, this method is used by (at least) ...
//  Ys IV - The Dawn of Ys
//  Gulliver Boy
//
// The bit buffer is stored hi-lo.
// The nibble buffer is stored hi-lo.
//
// The compression has no end-of-file marker, and data is decompressed until
// all of the source file is used, whether the data makes sense or not.
//
// Ys4 and Gulliver add a 1-byte header to signal whether the compressed data
// is encoded in byte (0) or word (1) format.
//
// This decompressor does NOT handle Ys4's word format scheme!
//

uint8_t * DecompressHLZ (
  uint8_t * pSrcBuffer, unsigned uSrcLength,
  uint8_t * pDstBuffer, unsigned uDstLength )

{
  // Local Variables.

  int iSrcOffset = 0;
  int iDstOffset = 0;
  int iMatchLength = 0;

  int iNibbleOffset = 0;

  uint8_t uBitMask = 0;
  uint8_t uBitFlag = 0;

  uint8_t uWinOffset;
  uint8_t uMatchOffset;

  uint8_t aWinBuffer[ 256 ];

  // Initialize the ring-buffer window, just in case Hudson really thought
  // that a preload filled with $00 bytes was actually a sane idea.
  //
  // N.B. I *hate* LZSS decompressors using a ring-buffer, it isn't needed
  // unless you are using a preload, and it just obfuscates the simplicity
  // of the LZSS algorithm.

  memset( aWinBuffer, 0, 256 );

  // Detect the Ys4 style compression-type.
  //
  // Since HLZ compression stores its LZSS flags hi-lo, and there absolutely
  // must be a COPY (a 1-bit) in the first few bits, normally in the top bit
  // if there is no preload, then the type can be easily determined.

  uWinOffset = 0xEF;

  if (pSrcBuffer[0] < 2) {
    // This must be the Ys4 style compression-type.

    if (pSrcBuffer[0] == 1) {
      printf( "hulz - Hudson's WORD compression is not supported!\n" );
      return (NULL);
    }

    uWinOffset = 0x00;
    ++iSrcOffset;
  }

  // Loop around decompressing data bytes until something stops us.

  while ((iSrcOffset <= (int) uSrcLength) && (iDstOffset < (int) uDstLength))
  {
    if (iMatchLength == 0)
    {
      // Before starting a new COPY or MATCH, is there any data left to decompress?

      if (iSrcOffset >= (int) uSrcLength) {
        break;
      }

      // Do we need to load another byte of flag bits?

      if (uBitMask == 0) {
        uBitFlag = pSrcBuffer[ iSrcOffset++ ];
        uBitMask = 0x80;
      }

      if (uBitFlag & uBitMask) {
        // COPY 1 byte.

        pDstBuffer[ iDstOffset++ ] =
        aWinBuffer[ uWinOffset++ ] = pSrcBuffer[ iSrcOffset++ ];
      } else {
        // Read MATCH offset.

        uMatchOffset = pSrcBuffer[ iSrcOffset++ ];

        // Read MATCH length.

        if (iNibbleOffset == 0) {
          iNibbleOffset = iSrcOffset++;
          iMatchLength = (pSrcBuffer[ iNibbleOffset ] >> 4) + 2;
        } else {
          iMatchLength = (pSrcBuffer[ iNibbleOffset ] & 15) + 2;
          iNibbleOffset = 0;
        }
      }

      uBitMask >>= 1;
    } else {
      // MATCH 1 byte.

      pDstBuffer[ iDstOffset++ ] =
      aWinBuffer[ uWinOffset++ ] = aWinBuffer[ uMatchOffset++ ];
      --iMatchLength;
    }
  }

  // Warn the user if something seems to be wrong.

  if ((iMatchLength != 0) || (iDstOffset == (int) uDstLength)) {
    printf( "hulz - WARNING, too much decompessed data, output truncated!\n" );
  } else {
    if (iSrcOffset != (int) uSrcLength) {
      printf( "hulz - WARNING, read passed the end of compressed data!\n" );
      printf( "hulz - The file is either too short or a byte too long.\n" );
    } else {
      if (uBitMask != 0) {
        do {
          if (uBitFlag & uBitMask) {
            printf( "hulz - WARNING, flag bits indicate the input file is too short!\n" );
          }
          uBitMask >>= 1;
        } while (uBitMask != 0);
      }
    }
  }

  return (pDstBuffer + iDstOffset);
}



// **************************************************************************
// **************************************************************************
//
// g_aHudsonPreload []
//
// Hudson's runtime-generated 4KByte preload for Anearth Fantasy Stories.
//

uint8_t g_aHudsonPreload [4096] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01, // |................|
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02, // |................|
  0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03, // |................|
  0x03,0x03,0x03,0x03,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04, // |................|
  0x04,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x06,0x06, // |................|
  0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x07,0x07,0x07,0x07,0x07, // |................|
  0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x07,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08, // |................|
  0x08,0x08,0x08,0x08,0x08,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09,0x09, // |................|
  0x09,0x09,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0a,0x0b, // |................|
  0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0b,0x0c,0x0c,0x0c,0x0c, // |................|
  0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0d, // |................|
  0x0d,0x0d,0x0d,0x0d,0x0d,0x0d,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e,0x0e, // |................|
  0x0e,0x0e,0x0e,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f, // |................|
  0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x11,0x11,0x11, // |................|
  0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x12,0x12,0x12,0x12,0x12,0x12, // |................|
  0x12,0x12,0x12,0x12,0x12,0x12,0x12,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13,0x13, // |................|
  0x13,0x13,0x13,0x13,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14,0x14, // |................|
  0x14,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x15,0x16,0x16, // |................|
  0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x16,0x17,0x17,0x17,0x17,0x17, // |................|
  0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x17,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, // |................|
  0x18,0x18,0x18,0x18,0x18,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19,0x19, // |................|
  0x19,0x19,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1a,0x1b, // |................|
  0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1b,0x1c,0x1c,0x1c,0x1c, // |................|
  0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1d, // |................|
  0x1d,0x1d,0x1d,0x1d,0x1d,0x1d,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e,0x1e, // |................|
  0x1e,0x1e,0x1e,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f, // |................|
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x21,0x21,0x21, // |             !!!|
  0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x21,0x22,0x22,0x22,0x22,0x22,0x22, // |!!!!!!!!!!""""""|
  0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23,0x23, // |"""""""#########|
  0x23,0x23,0x23,0x23,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x24, // |####$$$$$$$$$$$$|
  0x24,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x25,0x26,0x26, // |$%%%%%%%%%%%%%&&|
  0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x26,0x27,0x27,0x27,0x27,0x27, // |&&&&&&&&&&&'''''|
  0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x27,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28, // |''''''''((((((((|
  0x28,0x28,0x28,0x28,0x28,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29,0x29, // |((((()))))))))))|
  0x29,0x29,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2a,0x2b, // |))*************+|
  0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2b,0x2c,0x2c,0x2c,0x2c, // |++++++++++++,,,,|
  0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2c,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2d, // |,,,,,,,,,-------|
  0x2d,0x2d,0x2d,0x2d,0x2d,0x2d,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e,0x2e, // |------..........|
  0x2e,0x2e,0x2e,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f,0x2f, // |.../////////////|
  0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x31,0x31, // |0000000000000111|
  0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x31,0x32,0x32,0x32,0x32,0x32,0x32, // |1111111111222222|
  0x32,0x32,0x32,0x32,0x32,0x32,0x32,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33, // |2222222333333333|
  0x33,0x33,0x33,0x33,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34,0x34, // |3333444444444444|
  0x34,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x35,0x36,0x36, // |4555555555555566|
  0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x37,0x37,0x37,0x37, // |6666666666677777|
  0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x37,0x38,0x38,0x38,0x38,0x38,0x38,0x38,0x38, // |7777777788888888|
  0x38,0x38,0x38,0x38,0x38,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39,0x39, // |8888899999999999|
  0x39,0x39,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3a,0x3b, // |99:::::::::::::;|
  0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3b,0x3c,0x3c,0x3c,0x3c, // |;;;;;;;;;;;;<<<<|
  0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3d, // |<<<<<<<<<=======|
  0x3d,0x3d,0x3d,0x3d,0x3d,0x3d,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e,0x3e, // |======>>>>>>>>>>|
  0x3e,0x3e,0x3e,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f, // |>>>?????????????|
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x41,0x41,0x41, // |@@@@@@@@@@@@@AAA|
  0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x41,0x42,0x42,0x42,0x42,0x42,0x42, // |AAAAAAAAAABBBBBB|
  0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43,0x43, // |BBBBBBBCCCCCCCCC|
  0x43,0x43,0x43,0x43,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44, // |CCCCDDDDDDDDDDDD|
  0x44,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x45,0x46,0x46, // |DEEEEEEEEEEEEEFF|
  0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x46,0x47,0x47,0x47,0x47,0x47, // |FFFFFFFFFFFGGGGG|
  0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x47,0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x48, // |GGGGGGGGHHHHHHHH|
  0x48,0x48,0x48,0x48,0x48,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0x49, // |HHHHHIIIIIIIIIII|
  0x49,0x49,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4b, // |IIJJJJJJJJJJJJJK|
  0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4b,0x4c,0x4c,0x4c,0x4c, // |KKKKKKKKKKKKLLLL|
  0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4c,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4d, // |LLLLLLLLLMMMMMMM|
  0x4d,0x4d,0x4d,0x4d,0x4d,0x4d,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e,0x4e, // |MMMMMMNNNNNNNNNN|
  0x4e,0x4e,0x4e,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f,0x4f, // |NNNOOOOOOOOOOOOO|
  0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x50,0x51,0x51,0x51, // |PPPPPPPPPPPPPQQQ|
  0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x51,0x52,0x52,0x52,0x52,0x52,0x52, // |QQQQQQQQQQRRRRRR|
  0x52,0x52,0x52,0x52,0x52,0x52,0x52,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53,0x53, // |RRRRRRRSSSSSSSSS|
  0x53,0x53,0x53,0x53,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54,0x54, // |SSSSTTTTTTTTTTTT|
  0x54,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x56,0x56, // |TUUUUUUUUUUUUUVV|
  0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x56,0x57,0x57,0x57,0x57,0x57, // |VVVVVVVVVVVWWWWW|
  0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x57,0x58,0x58,0x58,0x58,0x58,0x58,0x58,0x58, // |WWWWWWWWXXXXXXXX|
  0x58,0x58,0x58,0x58,0x58,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59, // |XXXXXYYYYYYYYYYY|
  0x59,0x59,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5a,0x5b, // |YYZZZZZZZZZZZZZ[|
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5c,0x5c,0x5c,0x5c, // |[[[[[[[[[[[[\\\\|
  0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5c,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5d, // |\\\\\\\\\]]]]]]]|
  0x5d,0x5d,0x5d,0x5d,0x5d,0x5d,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e,0x5e, // |]]]]]]^^^^^^^^^^|
  0x5e,0x5e,0x5e,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f,0x5f, // |^^^_____________|
  0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x61,0x61,0x61, // |`````````````aaa|
  0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x61,0x62,0x62,0x62,0x62,0x62,0x62, // |aaaaaaaaaabbbbbb|
  0x62,0x62,0x62,0x62,0x62,0x62,0x62,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63, // |bbbbbbbccccccccc|
  0x63,0x63,0x63,0x63,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64,0x64, // |ccccdddddddddddd|
  0x64,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x65,0x66,0x66, // |deeeeeeeeeeeeeff|
  0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x67,0x67,0x67,0x67,0x67, // |fffffffffffggggg|
  0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x67,0x68,0x68,0x68,0x68,0x68,0x68,0x68,0x68, // |gggggggghhhhhhhh|
  0x68,0x68,0x68,0x68,0x68,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69,0x69, // |hhhhhiiiiiiiiiii|
  0x69,0x69,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6a,0x6b, // |iijjjjjjjjjjjjjk|
  0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6b,0x6c,0x6c,0x6c,0x6c, // |kkkkkkkkkkkkllll|
  0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6d, // |lllllllllmmmmmmm|
  0x6d,0x6d,0x6d,0x6d,0x6d,0x6d,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e,0x6e, // |mmmmmmnnnnnnnnnn|
  0x6e,0x6e,0x6e,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f,0x6f, // |nnnooooooooooooo|
  0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x70,0x71,0x71,0x71, // |pppppppppppppqqq|
  0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x71,0x72,0x72,0x72,0x72,0x72,0x72, // |qqqqqqqqqqrrrrrr|
  0x72,0x72,0x72,0x72,0x72,0x72,0x72,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73,0x73, // |rrrrrrrsssssssss|
  0x73,0x73,0x73,0x73,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74,0x74, // |sssstttttttttttt|
  0x74,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x75,0x76,0x76, // |tuuuuuuuuuuuuuvv|
  0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x76,0x77,0x77,0x77,0x77,0x77, // |vvvvvvvvvvvwwwww|
  0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x77,0x78,0x78,0x78,0x78,0x78,0x78,0x78,0x78, // |wwwwwwwwxxxxxxxx|
  0x78,0x78,0x78,0x78,0x78,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79,0x79, // |xxxxxyyyyyyyyyyy|
  0x79,0x79,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7a,0x7b, // |yyzzzzzzzzzzzzz{|
  0x7b,0x7b,0x7b,0x7b,0x7b,0x7b,0x7b,0x7b,0x7b,0x7b,0x7b,0x7b,0x7c,0x7c,0x7c,0x7c, // |{{{{{{{{{{{{|||||
  0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7d, // ||||||||||}}}}}}}|
  0x7d,0x7d,0x7d,0x7d,0x7d,0x7d,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e, // |}}}}}}~~~~~~~~~~|
  0x7e,0x7e,0x7e,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f, // |~~~.............|
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x81,0x81,0x81, // |................|
  0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x81,0x82,0x82,0x82,0x82,0x82,0x82, // |................|
  0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83,0x83, // |................|
  0x83,0x83,0x83,0x83,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84, // |................|
  0x84,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x85,0x86,0x86, // |................|
  0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x86,0x87,0x87,0x87,0x87,0x87, // |................|
  0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x87,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88, // |................|
  0x88,0x88,0x88,0x88,0x88,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89,0x89, // |................|
  0x89,0x89,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8a,0x8b, // |................|
  0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8b,0x8c,0x8c,0x8c,0x8c, // |................|
  0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8c,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8d, // |................|
  0x8d,0x8d,0x8d,0x8d,0x8d,0x8d,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e,0x8e, // |................|
  0x8e,0x8e,0x8e,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f,0x8f, // |................|
  0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x90,0x91,0x91,0x91, // |................|
  0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x91,0x92,0x92,0x92,0x92,0x92,0x92, // |................|
  0x92,0x92,0x92,0x92,0x92,0x92,0x92,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93,0x93, // |................|
  0x93,0x93,0x93,0x93,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94,0x94, // |................|
  0x94,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x95,0x96,0x96, // |................|
  0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x96,0x97,0x97,0x97,0x97,0x97, // |................|
  0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x97,0x98,0x98,0x98,0x98,0x98,0x98,0x98,0x98, // |................|
  0x98,0x98,0x98,0x98,0x98,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99,0x99, // |................|
  0x99,0x99,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9a,0x9b, // |................|
  0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9b,0x9c,0x9c,0x9c,0x9c, // |................|
  0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9c,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9d, // |................|
  0x9d,0x9d,0x9d,0x9d,0x9d,0x9d,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e,0x9e, // |................|
  0x9e,0x9e,0x9e,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f,0x9f, // |................|
  0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa0,0xa1,0xa1,0xa1, // |................|
  0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa1,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2, // |................|
  0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa2,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3,0xa3, // |................|
  0xa3,0xa3,0xa3,0xa3,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4,0xa4, // |................|
  0xa4,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa5,0xa6,0xa6, // |................|
  0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa6,0xa7,0xa7,0xa7,0xa7,0xa7, // |................|
  0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa7,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8,0xa8, // |................|
  0xa8,0xa8,0xa8,0xa8,0xa8,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9,0xa9, // |................|
  0xa9,0xa9,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xab, // |................|
  0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xab,0xac,0xac,0xac,0xac, // |................|
  0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xac,0xad,0xad,0xad,0xad,0xad,0xad,0xad, // |................|
  0xad,0xad,0xad,0xad,0xad,0xad,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae,0xae, // |................|
  0xae,0xae,0xae,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf,0xaf, // |................|
  0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb0,0xb1,0xb1,0xb1, // |................|
  0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb1,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2, // |................|
  0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb2,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3,0xb3, // |................|
  0xb3,0xb3,0xb3,0xb3,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4,0xb4, // |................|
  0xb4,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb5,0xb6,0xb6, // |................|
  0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb6,0xb7,0xb7,0xb7,0xb7,0xb7, // |................|
  0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb7,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8,0xb8, // |................|
  0xb8,0xb8,0xb8,0xb8,0xb8,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9,0xb9, // |................|
  0xb9,0xb9,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xba,0xbb, // |................|
  0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbb,0xbc,0xbc,0xbc,0xbc, // |................|
  0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbc,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbd, // |................|
  0xbd,0xbd,0xbd,0xbd,0xbd,0xbd,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe, // |................|
  0xbe,0xbe,0xbe,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf,0xbf, // |................|
  0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc1,0xc1,0xc1, // |................|
  0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc1,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2, // |................|
  0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc2,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3, // |................|
  0xc3,0xc3,0xc3,0xc3,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4,0xc4, // |................|
  0xc4,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc5,0xc6,0xc6, // |................|
  0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc7,0xc7,0xc7,0xc7,0xc7, // |................|
  0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,0xc7,0xc8,0xc8,0xc8,0xc8,0xc8,0xc8,0xc8,0xc8, // |................|
  0xc8,0xc8,0xc8,0xc8,0xc8,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9,0xc9, // |................|
  0xc9,0xc9,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xca,0xcb, // |................|
  0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcb,0xcc,0xcc,0xcc,0xcc, // |................|
  0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xcd, // |................|
  0xcd,0xcd,0xcd,0xcd,0xcd,0xcd,0xce,0xce,0xce,0xce,0xce,0xce,0xce,0xce,0xce,0xce, // |................|
  0xce,0xce,0xce,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf,0xcf, // |................|
  0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd0,0xd1,0xd1,0xd1, // |................|
  0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd1,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2, // |................|
  0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd2,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3,0xd3, // |................|
  0xd3,0xd3,0xd3,0xd3,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4,0xd4, // |................|
  0xd4,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd5,0xd6,0xd6, // |................|
  0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xd7,0xd7,0xd7,0xd7,0xd7, // |................|
  0xd7,0xd7,0xd7,0xd7,0xd7,0xd7,0xd7,0xd7,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8,0xd8, // |................|
  0xd8,0xd8,0xd8,0xd8,0xd8,0xd9,0xd9,0xd9,0xd9,0xd9,0xd9,0xd9,0xd9,0xd9,0xd9,0xd9, // |................|
  0xd9,0xd9,0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xda,0xdb, // |................|
  0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdc,0xdc,0xdc,0xdc, // |................|
  0xdc,0xdc,0xdc,0xdc,0xdc,0xdc,0xdc,0xdc,0xdc,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd, // |................|
  0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xde,0xde, // |................|
  0xde,0xde,0xde,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf,0xdf, // |................|
  0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe0,0xe1,0xe1,0xe1, // |................|
  0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe1,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2, // |................|
  0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe2,0xe3,0xe3,0xe3,0xe3,0xe3,0xe3,0xe3,0xe3,0xe3, // |................|
  0xe3,0xe3,0xe3,0xe3,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4,0xe4, // |................|
  0xe4,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe6,0xe6, // |................|
  0xe6,0xe6,0xe6,0xe6,0xe6,0xe6,0xe6,0xe6,0xe6,0xe6,0xe6,0xe7,0xe7,0xe7,0xe7,0xe7, // |................|
  0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe7,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8,0xe8, // |................|
  0xe8,0xe8,0xe8,0xe8,0xe8,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9,0xe9, // |................|
  0xe9,0xe9,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xea,0xeb, // |................|
  0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xeb,0xec,0xec,0xec,0xec, // |................|
  0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xec,0xed,0xed,0xed,0xed,0xed,0xed,0xed, // |................|
  0xed,0xed,0xed,0xed,0xed,0xed,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee,0xee, // |................|
  0xee,0xee,0xee,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef,0xef, // |................|
  0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf1,0xf1,0xf1, // |................|
  0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf1,0xf2,0xf2,0xf2,0xf2,0xf2,0xf2, // |................|
  0xf2,0xf2,0xf2,0xf2,0xf2,0xf2,0xf2,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3,0xf3, // |................|
  0xf3,0xf3,0xf3,0xf3,0xf4,0xf4,0xf4,0xf4,0xf4,0xf4,0xf4,0xf4,0xf4,0xf4,0xf4,0xf4, // |................|
  0xf4,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf5,0xf6,0xf6, // |................|
  0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf6,0xf7,0xf7,0xf7,0xf7,0xf7, // |................|
  0xf7,0xf7,0xf7,0xf7,0xf7,0xf7,0xf7,0xf7,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8, // |................|
  0xf8,0xf8,0xf8,0xf8,0xf8,0xf9,0xf9,0xf9,0xf9,0xf9,0xf9,0xf9,0xf9,0xf9,0xf9,0xf9, // |................|
  0xf9,0xf9,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfa,0xfb, // |................|
  0xfb,0xfb,0xfb,0xfb,0xfb,0xfb,0xfb,0xfb,0xfb,0xfb,0xfb,0xfb,0xfc,0xfc,0xfc,0xfc, // |................|
  0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0xfd, // |................|
  0xfd,0xfd,0xfd,0xfd,0xfd,0xfd,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe, // |................|
  0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff, // |................|
  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f, // |................|
  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f, // |................|
  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f, // | !"#$%&'()*+,-./|
  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f, // |0123456789:;<=>?|
  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f, // |@ABCDEFGHIJKLMNO|
  0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f, // |PQRSTUVWXYZ[\]^_|
  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f, // |`abcdefghijklmno|
  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f, // |pqrstuvwxyz{|}~.|
  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f, // |................|
  0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f, // |................|
  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf, // |................|
  0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf, // |................|
  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf, // |................|
  0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf, // |................|
  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef, // |................|
  0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff, // |................|
  0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0, // |................|
  0xef,0xee,0xed,0xec,0xeb,0xea,0xe9,0xe8,0xe7,0xe6,0xe5,0xe4,0xe3,0xe2,0xe1,0xe0, // |................|
  0xdf,0xde,0xdd,0xdc,0xdb,0xda,0xd9,0xd8,0xd7,0xd6,0xd5,0xd4,0xd3,0xd2,0xd1,0xd0, // |................|
  0xcf,0xce,0xcd,0xcc,0xcb,0xca,0xc9,0xc8,0xc7,0xc6,0xc5,0xc4,0xc3,0xc2,0xc1,0xc0, // |................|
  0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0, // |................|
  0xaf,0xae,0xad,0xac,0xab,0xaa,0xa9,0xa8,0xa7,0xa6,0xa5,0xa4,0xa3,0xa2,0xa1,0xa0, // |................|
  0x9f,0x9e,0x9d,0x9c,0x9b,0x9a,0x99,0x98,0x97,0x96,0x95,0x94,0x93,0x92,0x91,0x90, // |................|
  0x8f,0x8e,0x8d,0x8c,0x8b,0x8a,0x89,0x88,0x87,0x86,0x85,0x84,0x83,0x82,0x81,0x80, // |................|
  0x7f,0x7e,0x7d,0x7c,0x7b,0x7a,0x79,0x78,0x77,0x76,0x75,0x74,0x73,0x72,0x71,0x70, // |.~}|{zyxwvutsrqp|
  0x6f,0x6e,0x6d,0x6c,0x6b,0x6a,0x69,0x68,0x67,0x66,0x65,0x64,0x63,0x62,0x61,0x60, // |onmlkjihgfedcba`|
  0x5f,0x5e,0x5d,0x5c,0x5b,0x5a,0x59,0x58,0x57,0x56,0x55,0x54,0x53,0x52,0x51,0x50, // |_^]\[ZYXWVUTSRQP|
  0x4f,0x4e,0x4d,0x4c,0x4b,0x4a,0x49,0x48,0x47,0x46,0x45,0x44,0x43,0x42,0x41,0x40, // |ONMLKJIHGFEDCBA@|
  0x3f,0x3e,0x3d,0x3c,0x3b,0x3a,0x39,0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x30, // |?>=<;:9876543210|
  0x2f,0x2e,0x2d,0x2c,0x2b,0x2a,0x29,0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,0x20, // |/.-,+*)('&%$#"! |
  0x1f,0x1e,0x1d,0x1c,0x1b,0x1a,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10, // |................|
  0x0f,0x0e,0x0d,0x0c,0x0b,0x0a,0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // |................|
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20, // |                |
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20, // |                |
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20, // |                |
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20, // |                |
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20, // |                |
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20, // |                |
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20, // |                |
  0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20  // |                |
};



// **************************************************************************
// **************************************************************************
//
// CompressAFS ()
//
// Compress data in Hudson's 4-bit length, 12-bit offset LZSS, with preload.
//
// The window offset is stored as relative to the start of the preload data,
// and not as a delta from the current output, and some games do not use all
// of the 4096-byte preload and start compressing at offset $xFEE instead of
// $x000.
//
// With a window start of $0FEE, this method is used by (at least) ...
//  Anearth Fantasy Stories
//
// The bit buffer is stored lo-hi.
//
// The compressed data is preceded by an 8-byte header containing the sizes
// of both the compressed and uncompressed data.
//

uint8_t * CompressAFS (
  uint8_t * pSrcBuffer, unsigned uSrcLength,
  uint8_t * pDstBuffer, unsigned uDstLength )

{
  // Local Variables.

  int iSrcOffset = 0;
  int iCopyCount = 0;
  int iSkipCount;

  int iHashValue;
  int iSrcRemain;
  int iBestOffset;
  int iBestLength;
  int iNextOffset;
  int iNextLength;

  uint8_t * pTmpBuffer = NULL;

  bool usePreload = true;

  // Set the search parameters for this particular LZSS-variant.

  const int iMinMatch = 3;
  const int iMaxMatch = 18;
  const int iMaxDelta = 0x1000;

  // Initialize the hash table and window for string matching.

  InitStringMatch();

  // Initialize the output, which begins with an 8-byte chunk header.

  g_pOutBuffer = pDstBuffer + 8;
  g_uOutLength = uDstLength - 8;

  BitInit();

  // Write the uncompressed length to the chunk header.

  pDstBuffer[4] = (uint8_t) (uSrcLength & 255);
  pDstBuffer[5] = (uint8_t) (uSrcLength / 256);
  pDstBuffer[6] = 0;
  pDstBuffer[7] = 0;

  // Handle preload by creating a copy of the pSrcBuffer.
  //
  // Hudson's AFS only uses 0x0FEE bytes out of the 0x1000 byte preload!

  pTmpBuffer = (uint8_t *) malloc( uSrcLength + 0x0FEE );

  memcpy( pTmpBuffer + 0x0000, g_aHudsonPreload, 0x0FEE );
  memcpy( pTmpBuffer + 0x0FEE, pSrcBuffer, uSrcLength );

  pSrcBuffer = pTmpBuffer;
  uSrcLength = uSrcLength + 0x0FEE;

  if (usePreload)
  {
    // Add preload data to the window of known strings.

    while (iSrcOffset != 0x0FEE)
    {
      iHashValue = CALC_HASH( iSrcOffset );

      g_pPrevOffset[ iSrcOffset & HASH_WIN_MASK ] = g_pHashOffset[ iHashValue ];
      g_pHashOffset[ iHashValue ] = iSrcOffset;

      ++iSrcOffset;
    }
  }
  else
  {
    // Ignore the preload data, but still start at offset 0x0FEE to keep
    // Hudson's decompressor happy.

    iSrcOffset = 0x0FEE;
  }

  // Loop around encoding strings until the buffer is empty.

  for (;;)
  {
    // Update the window and calc how much data is left to compress.

    iSrcRemain = uSrcLength - iSrcOffset;

    if (iSrcRemain < iMinMatch) {
      iSrcOffset += iSrcRemain;
      iCopyCount += iSrcRemain;
      break;
    }

    // Find the best match at the current position.

    iBestLength = 0;

    if (iSrcOffset != 0) {
      FindStringMatch( &iBestOffset, &iBestLength, pSrcBuffer, uSrcLength, iSrcOffset, iMaxDelta, iMaxMatch );
    }

    // Move the window on by 1 byte.

    iHashValue = CALC_HASH( iSrcOffset );

    g_pPrevOffset[ iSrcOffset & HASH_WIN_MASK ] = g_pHashOffset[ iHashValue ];
    g_pHashOffset[ iHashValue ] = iSrcOffset;

    // Lazy match (compresses up to 1% better on a good day, usually less).
    //
    // Basically, if you can compress 1 extra byte, then that is a better thing
    // to do instead of encoding 2 literals after the current match.

    if (g_fLazyMatch)
    {
      if ((iBestLength >= iMinMatch) && (iBestLength < iMaxMatch) && (iSrcRemain != iMinMatch))
      {
        FindStringMatch( &iNextOffset, &iNextLength, pSrcBuffer, uSrcLength, iSrcOffset + 1, iMaxDelta, iMaxMatch );

        if (iNextLength > iBestLength) {
          ++iCopyCount;
          ++iSrcOffset;
          iBestLength = iNextLength;
          iBestOffset = iNextOffset;
        }
      }
    }

    // Keep track of COPY bytes, but don't process them, yet.

    if (iBestLength < iMinMatch) {
      ++iCopyCount;
      ++iSrcOffset;
      continue;
    }

    // First, write any COPY bytes.

    if (iCopyCount)
    {
      uint8_t * pCopyFrom = pSrcBuffer + iSrcOffset - iCopyCount;

      do {
        // Signal that COPY is next.

        BitWriteLoHi( 1 );

        *g_pOutBuffer++ = *pCopyFrom++;
      } while (--iCopyCount);
    }

    // Then write the LZSS "match".
    //
    // Mark this as an LZSS and not a COPY.

    BitWriteLoHi( 0 );

    // In Hudson's compression, the offset is not relative to the output, but
    // is actually the index into the 4KB window[] array!

    g_pOutBuffer[0] = (uint8_t) (iBestOffset & 255);
    g_pOutBuffer[1] = (uint8_t) ((0xF0u & (iBestOffset >> 4)) + (iBestLength - 3));

    g_pOutBuffer += 2;

    // Skip passed "matched" bytes, updating the window contents.

    ++iSrcOffset;

    iSkipCount = iBestLength - 1;

    while (iSkipCount--)
    {
      iHashValue = CALC_HASH( iSrcOffset );

      g_pPrevOffset[ iSrcOffset & HASH_WIN_MASK ] = g_pHashOffset[ iHashValue ];
      g_pHashOffset[ iHashValue ] = iSrcOffset;

      ++iSrcOffset;
    }

  } // End of "for (;;)"

  // Encode the last COPY byte(s) (if there are any).

  if (iCopyCount)
  {
    uint8_t * pCopyFrom = pSrcBuffer + iSrcOffset - iCopyCount;

    do {
      // Signal that COPY is next.

      BitWriteLoHi( 1 );

      *g_pOutBuffer++ = *pCopyFrom++;
    } while (--iCopyCount);
  }

  // Write the compressed length to the chunk header.

  uDstLength = g_pOutBuffer - (pDstBuffer + 8);

  pDstBuffer[0] = (uint8_t) (uDstLength & 255);
  pDstBuffer[1] = (uint8_t) (uDstLength / 256);
  pDstBuffer[2] = 0;
  pDstBuffer[3] = 0;

  // Free up the preload buffer.

  if (pTmpBuffer != NULL)
    free( pTmpBuffer );

  // All done.

  return (g_pOutBuffer);
}



// **************************************************************************
// **************************************************************************
//
// DecompressAFS ()
//
// Decompress data in Hudson's 4-bit length, 12-bit offset LZSS, with buffer
// preload.
//
// The window offset is stored as relative to the start of the preload data,
// and not as a delta from the current output, and some games do not use all
// of the 4096-byte preload and start compressing at offset $xFEE instead of
// $x000.
//
// With a window start of $0FEE, this method is used by (at least) ...
//  Anearth Fantasy Stories
//
// The bit buffer is stored lo-hi.
//
// The compressed data is preceded by an 8-byte header containing the sizes
// of both the compressed and uncompressed data.
//

uint8_t * DecompressAFS (
  uint8_t * pSrcBuffer, unsigned uSrcLength,
  uint8_t * pDstBuffer, unsigned uDstLength )

{
  // Local Variables.

  int iSrcLength;
  int iDstLength;

  int iSrcOffset = 0;
  int iDstOffset = 0;
  int iMatchLength = 0;

  uint8_t uBitMask = 0;
  uint8_t uBitFlag = 0;

  int iWinOffset;
  int iMatchOffset;

  uint8_t aWinBuffer[ 4096 ];

  // Initialize the ring-buffer window.

  memcpy( aWinBuffer, g_aHudsonPreload, 4096 );

  iWinOffset = 0x0FEE;

  // Read the compressed and decompressed sizes from the header.

  iSrcLength = pSrcBuffer[0] + (0x00000100 * pSrcBuffer[1]) + (0x00010000 * pSrcBuffer[2]) + (0x01000000 * pSrcBuffer[3]);
  iDstLength = pSrcBuffer[4] + (0x00000100 * pSrcBuffer[5]) + (0x00010000 * pSrcBuffer[6]) + (0x01000000 * pSrcBuffer[7]);

  if ((iSrcLength < 0) || (uSrcLength < (unsigned) (iSrcLength + 8))) {
    printf( "hulz - ERROR, header indicates some compressed data is missing!\n" );
    return (NULL);
  }

  iSrcLength += 8;

  if ((iDstLength < 0) || (uDstLength < (unsigned) (iDstLength))) {
    printf( "hulz - ERROR, header says the decompressed data is more than %u bytes!\n", uDstLength );
    return (NULL);
  }

  iSrcOffset = 8;

  // Loop around decompressing data bytes until something stops us.

  while ((iSrcOffset <= iSrcLength) && (iDstOffset < iDstLength))
  {
    if (iMatchLength == 0)
    {
      // Before starting a new COPY or MATCH, is there any data left to decompress?

      if (iSrcOffset >= (int) uSrcLength) {
        break;
      }

      // Do we need to load another byte of flag bits?

      if (uBitMask == 0) {
        uBitFlag = pSrcBuffer[ iSrcOffset++ ];
        uBitMask = 0x01;
      }

      if (uBitFlag & uBitMask) {
        // COPY 1 byte.

        pDstBuffer[ iDstOffset++ ] =
        aWinBuffer[ iWinOffset++ ] = pSrcBuffer[ iSrcOffset++ ];
        iWinOffset &= 0x0FFF;
      } else {
        // Read MATCH offset.

        iMatchOffset = pSrcBuffer[ iSrcOffset++ ];
        iMatchOffset = iMatchOffset + 256 * (pSrcBuffer[ iSrcOffset ] >> 4);

        // Read MATCH length.

        iMatchLength = (pSrcBuffer[ iSrcOffset++ ] & 15) + 3;
      }

      uBitMask <<= 1;
    } else {
      // MATCH 1 byte.

      pDstBuffer[ iDstOffset++ ] =
      aWinBuffer[ iWinOffset++ ] = aWinBuffer[ iMatchOffset++ ];
      iWinOffset   &= 0x0FFF;
      iMatchOffset &= 0x0FFF;
      --iMatchLength;
    }
  }

  // Warn the user if something seems to be wrong.

  if ((iMatchLength != 0) || (iDstOffset != iDstLength)) {
    printf( "hulz - WARNING, decompessed data length does not match length in header!\n" );
  } else {
    if (iSrcOffset != iSrcLength) {
      printf( "hulz - WARNING, read passed the end of compressed data!\n" );
    } else {
      if (uBitMask != 0) {
        do {
          if (uBitFlag & uBitMask) {
            printf( "hulz - WARNING, flag bits indicate the input file is too short!\n" );
          }
          uBitMask <<= 1;
        } while (uBitMask != 0);
      }
    }
  }

  return (pDstBuffer + iDstOffset);
}



// **************************************************************************
// **************************************************************************
//
// CompressLZ8 ()
//
// Compress data in Elmer's 16-bit length, 8-bit offset LZ4-variant.
//
// The window offset is stored as relative to the start of the data, and not
// as a delta from the current output, which is quicker for decompression to
// a page-aligned output (or ring-buffer).
//
// Both COPY and MATCH counts are encoded as variable-length formats, either
// nibble or nibble+byte or nibble+byte+word.
//
// The nibble buffer is stored hi-lo.
//
// N.B. This is a pretty useless format, please use ZX0 instead!
//

uint8_t * CompressLZ8 (
  uint8_t * pSrcBuffer, unsigned uSrcLength,
  uint8_t * pDstBuffer, unsigned uDstLength )

{
  // Local Variables.

  int iSrcOffset = 0;
  int iCopyCount = 0;
  int iSkipCount;

  int iHashValue;
  int iSrcRemain;
  int iBestOffset;
  int iBestLength;
  int iNextOffset;
  int iNextLength;
  int iPrevOffset = 0;
  int iPrevLength = 0;

  // Set the search parameters for this particular LZSS-variant.

  const int iMinMatch = 2;
  const int iMaxMatch = 65536;
  const int iMaxDelta = 256;

  // Initialize the hash table and window for string matching.

  InitStringMatch();

  // Initialize the output.

  g_pOutBuffer = pDstBuffer;
  g_uOutLength = uDstLength;

  BitInit();
  NibbleInit();

  // Loop around encoding strings until the buffer is empty.

  for (;;)
  {
    // Update the window and calc how much data is left to compress.

    iSrcRemain = uSrcLength - iSrcOffset;

    if (iSrcRemain < iMinMatch) {
      iSrcOffset += iSrcRemain;
      iCopyCount += iSrcRemain;
      break;
    }

    // Find the best match at the current position.

    iBestLength = 0;

    if (iSrcOffset != 0) {
      FindStringMatch( &iBestOffset, &iBestLength, pSrcBuffer, uSrcLength, iSrcOffset, iMaxDelta, iMaxMatch );
    }

    // Move the window on by 1 byte.

    iHashValue = CALC_HASH( iSrcOffset );

    g_pPrevOffset[ iSrcOffset & HASH_WIN_MASK ] = g_pHashOffset[ iHashValue ];
    g_pHashOffset[ iHashValue ] = iSrcOffset;

    // Lazy match (compresses up to 1% better on a good day, usually less).
    //
    // With variable-length encoding, the cost of ignoring the current match is
    // rather ugly to calculate.

    if (g_fLazyMatch)
    {
      if ((iBestLength >= iMinMatch) && (iBestLength < iMaxMatch) && (iSrcRemain != iMinMatch))
      {
        int iLazyCost = 8;

        FindStringMatch( &iNextOffset, &iNextLength, pSrcBuffer, uSrcLength, iSrcOffset + 1, iMaxDelta, iMaxMatch );

        if (iCopyCount == 0) {
          iLazyCost += 4;
        } else
        if (iCopyCount == 15) {
          iLazyCost += 8;
        } else
        if (iCopyCount == 255) {
          iLazyCost += 16;
        }

        if (iBestLength <= 16) {
          if (iNextLength > 256) {
            iLazyCost += 16;
          } else
          if (iNextLength > 16) {
            iLazyCost += 8;
          }
        } else
        if (iBestLength <= 256) {
          if (iNextLength > 256) {
            iLazyCost += 16;
          }
        }

        iLazyCost = (iLazyCost + 7) / 8;

        if (iNextLength >= (iBestLength + iLazyCost)) {
          ++iCopyCount;
          ++iSrcOffset;
          iBestLength = iNextLength;
          iBestOffset = iNextOffset;
        }
      }
    }

    // Keep track of COPY bytes, but don't process them, yet.

    if (iBestLength < iMinMatch) {
      ++iCopyCount;
      ++iSrcOffset;
      continue;
    }

    // Got a new LZSS match!
    //
    // First, write the previous match now that we know what follows it.

    if (iPrevLength) {
      // Save LZSS length with "followed-by-copy-or-lzss" flag in the bottom bit.

      int iTempLength = ((iPrevLength - 1) * 2) + ((iCopyCount == 0) ? 1 : 0);

      if (iTempLength < 16) {
        NibbleWriteHiLo( iTempLength );
      } else {
        NibbleWriteHiLo( 0 );
        if (iTempLength < 256) {
          *g_pOutBuffer++ = iTempLength;
        } else {
          *g_pOutBuffer++ = 0;
          *g_pOutBuffer++ = (iTempLength >> 8);
          *g_pOutBuffer++ = (iTempLength & 255);
        }
      }

      // Save LZSS offset.

      *g_pOutBuffer++ = iPrevOffset & 255;
    }

    // Then write any COPY bytes.

    if (iCopyCount) {
      uint8_t * pCopyFrom;

      // Save COPY length.

      if (iCopyCount < 16) {
        NibbleWriteHiLo( iCopyCount );
      } else {
        NibbleWriteHiLo( 0 );
        if (iCopyCount < 256) {
          *g_pOutBuffer++ = iCopyCount;
        } else {
          *g_pOutBuffer++ = 0;
          *g_pOutBuffer++ = (iCopyCount >> 8) - (((iCopyCount & 255) == 0) ? 1 : 0);
          *g_pOutBuffer++ = (iCopyCount & 255);
        }
      }

      // Save each individual COPY byte.

      pCopyFrom = pSrcBuffer + iSrcOffset - iCopyCount;

      do {
        *g_pOutBuffer++ = *pCopyFrom++;
      } while (--iCopyCount);
    }

    // Remember the LZSS "match", but don't write it until we know what follows it.

    iPrevLength = iBestLength;
    iPrevOffset = iBestOffset;

    // Skip passed "matched" bytes, updating the window contents.

    ++iSrcOffset;

    iSkipCount = iBestLength - 1;

    while (iSkipCount--)
    {
      iHashValue = CALC_HASH( iSrcOffset );

      g_pPrevOffset[ iSrcOffset & HASH_WIN_MASK ] = g_pHashOffset[ iHashValue ];
      g_pHashOffset[ iHashValue ] = iSrcOffset;

      ++iSrcOffset;
    }

  } // End of "for (;;)"

  // We have now reached the end of the data to compress!
  //
  // First, write the previous match now that we know what follows it.

  if (iPrevLength) {
    // Save LZSS length with "what-comes-next" flag in the bottom bit.

    int iTempLength = ((iPrevLength - 1) * 2) + ((iCopyCount == 0) ? 1 : 0);

    if (iTempLength < 16) {
      NibbleWriteHiLo( iTempLength );
    } else {
      NibbleWriteHiLo( 0 );
      if (iTempLength < 256) {
        *g_pOutBuffer++ = iTempLength;
      } else {
        *g_pOutBuffer++ = 0;
        *g_pOutBuffer++ = (iTempLength >> 8);
        *g_pOutBuffer++ = (iTempLength & 255);
      }
    }

    // Save LZSS offset.

    *g_pOutBuffer++ = iPrevOffset & 255;
  }

  // Write the last COPY byte(s) (if there are any).

  if (iCopyCount) {
    uint8_t * pCopyFrom;

    // Save COPY length.

    if (iCopyCount < 16) {
      NibbleWriteHiLo( iCopyCount );
    } else {
      NibbleWriteHiLo( 0 );
      if (iCopyCount < 256) {
        *g_pOutBuffer++ = iCopyCount;
      } else {
        *g_pOutBuffer++ = 0;
        *g_pOutBuffer++ = (iCopyCount >> 8) - (((iCopyCount & 255) == 0) ? 1 : 0);
        *g_pOutBuffer++ = (iCopyCount & 255);
      }
    }

    // Save each individual COPY byte.

    pCopyFrom = pSrcBuffer + iSrcOffset - iCopyCount;

    do {
      *g_pOutBuffer++ = *pCopyFrom++;
    } while (--iCopyCount);
  }

  // Write the end-of-file token.

  NibbleWriteHiLo( 0 );

  *g_pOutBuffer++ = 1;

  // All done.

  return (g_pOutBuffer);
}



// **************************************************************************
// **************************************************************************
//
// DecompressLZ8 ()
//
// Compress data in Elmer's 16-bit length, 8-bit offset LZ4-variant.
//
// The window offset is stored as relative to the start of the data, and not
// as a delta from the current output, which is quicker for decompression to
// a page-aligned output (or ring-buffer).
//
// Both COPY and MATCH counts are encoded as variable-length formats, either
// nibble or nibble+byte or nibble+byte+word.
//
// The nibble buffer is stored hi-lo.
//
// N.B. This is a pretty useless format, please use ZX0 instead!
//

uint8_t * DecompressLZ8 (
  uint8_t * pSrcBuffer, unsigned uSrcLength,
  uint8_t * pDstBuffer, unsigned uDstLength )

{
  // Local Variables.

  int iSrcOffset = 0;
  int iDstOffset = 0;

  int iMatchIsNext = 0;

  int iCopyLength = 0;
  int iMatchLength = 0;

  uint8_t * pNibbleOffset = NULL;

  uint8_t uWinOffset = 0;
  uint8_t uMatchOffset = 0;

  uint8_t aWinBuffer[ 256 ];

  // Initialize the ring-buffer window.
  //
  // N.B. I *hate* LZSS decompressors using a ring-buffer, it isn't needed
  // unless you are using a preload, and it just obfuscates the simplicity
  // of the LZSS algorithm ... but I guess that it's a simple way to avoid
        // reading outside the buffer area if we're given bad data to decompress.

  memset( aWinBuffer, 0, 256 );

  // Loop around decompressing data bytes until something stops us.

  while ((iSrcOffset <= (int) uSrcLength) && (iDstOffset < (int) uDstLength))
  {
    if ((iCopyLength == 0) && (iMatchLength == 0))
    {
      int iLength;

      // Before starting a new COPY or MATCH, is there any data left to decompress?
      //
      // This shouldn't be necessary with an EOF marker, but it helps if given bad
      // data.

      if (iSrcOffset >= (int) uSrcLength) {
        break;
      }

      // Read the next length.

      if (pNibbleOffset == NULL) {
        pNibbleOffset = pSrcBuffer + iSrcOffset++;
        iLength = (*pNibbleOffset >> 4);
      } else {
        iLength = (*pNibbleOffset & 15);
        pNibbleOffset = NULL;
      }

      if (iLength == 0) {
        // Read 8-bit length.

        iLength = pSrcBuffer[ iSrcOffset++ ];

        if (iLength == 1) {
          // Got EOF marker.

          break;
        }

        if (iLength == 0) {
          // Read 16-bit length.

          iLength = 256 * pSrcBuffer[ iSrcOffset++ ];
          iLength = iLength + pSrcBuffer[ iSrcOffset++ ];
        }
      }

      // Now that we've got the length, what to do with it?

      if (iMatchIsNext == 0) {
        iMatchIsNext = 1;

        // Set COPY length.

        iCopyLength = iLength;
        if ((iLength & 255) == 0) iCopyLength += 256;
      } else {
        iMatchIsNext = iLength & 1;

        // Set MATCH length.

        iMatchLength = (iLength >> 1) + 1;

        // Get MATCH offset.

        uMatchOffset = pSrcBuffer[ iSrcOffset++ ];
      }
    } else {
                        // There's still an incomplete COPY or MATCH to process.

      if (iMatchLength == 0) {
        // COPY 1 byte.

        pDstBuffer[ iDstOffset++ ] =
        aWinBuffer[ uWinOffset++ ] = pSrcBuffer[ iSrcOffset++ ];
        --iCopyLength;
      } else {
        // MATCH 1 byte.

        pDstBuffer[ iDstOffset++ ] =
        aWinBuffer[ uWinOffset++ ] = aWinBuffer[ uMatchOffset++ ];
        --iMatchLength;
      }
    }
  }

  // Warn the user if something seems to be wrong.

  if (iDstOffset == (int) uDstLength) {
    printf( "hulz - WARNING, too much decompessed data, output truncated!\n" );
  } else
  if ((iCopyLength != 0) || (iMatchLength != 0) || (iSrcOffset != (int) uSrcLength)) {
    printf( "hulz - WARNING, read passed the end of compressed data!\n" );
    printf( "hulz - The file is probably too short.\n" );
  }

  return (pDstBuffer + iDstOffset);
}



// **************************************************************************
// **************************************************************************
//
// ReadBinaryFile ()
//
// Uses POSIX file functions rather than C file functions.
//
// Google "FIO19-C" for the reason why.
//
// N.B. Will return an error for files larger than 2GB on a 32-bit system.
//
// N.B. Pads allocated buffer size to next 16-byte boundary.
//

bool ReadBinaryFile ( const char *pName, uint8_t **pBuffer, size_t *pLength )
{
  uint8_t *     pData = NULL;
  off_t         uSize;
  struct stat   cStat;

  int hFile = open( pName, O_BINARY | O_RDONLY );

  if (hFile == -1)
    goto errorExit;

  if ((fstat( hFile, &cStat ) != 0) || (!S_ISREG( cStat.st_mode )))
    goto errorExit;

  if (cStat.st_size > SSIZE_MAX)
    goto errorExit;

  uSize = cStat.st_size;

  pData = (uint8_t *) calloc( (uSize + 15) >> 4, 16 );

  if (pData == NULL)
    goto errorExit;

  if (read( hFile, pData, uSize ) != uSize)
    goto errorExit;

  close(  hFile );

  *pBuffer = pData;
  *pLength = uSize;

  return (true);

  // Handle errors.

errorExit:

  if (pData != NULL) free( pData );
  if (hFile >= 0) close( hFile );

  *pBuffer = NULL;
  *pLength = 0;

  return (false);
}



// **************************************************************************
// **************************************************************************
//
// WriteBinaryFile ()
//
// Uses POSIX file functions rather than C file functions, just because
// it might save some space since ReadBinaryFile() uses POSIX functions.
//

bool WriteBinaryFile ( const char *pName, uint8_t *pBuffer, size_t iLength )
{
  int hFile = open( pName, O_BINARY | O_WRONLY | O_CREAT | O_TRUNC, S_IREAD | S_IWRITE );

  if (hFile == -1)
    goto errorExit;

  if (write( hFile, pBuffer, iLength) != iLength )
    goto errorExit;

  close( hFile );

  return (true);

  // Handle errors.

errorExit:

  if (hFile >= 0) close( hFile );

  return (false);
}



// **************************************************************************
// **************************************************************************
//
// ProcessFile ()
//

int ProcessFile ( const char *pSrcName, const char *pDstName )

{
  // Local variables.

  uint8_t * pSrcBuffer = NULL;
  size_t  uSrcLength = 0;

  uint8_t * pDstBuffer = NULL;
  size_t  uDstLength = 0;

  uint8_t * pDstFinish = NULL;

  // Read the original data from the source file.

  if (!ReadBinaryFile( pSrcName, &pSrcBuffer, &uSrcLength ))
  {
    printf( "hulz - Unable to read \"%s\" into memory!\n", pSrcName );
    return (1);
  }

  // Some of Hudson's compression schemes are limited to a 16-bit length.

  if (uSrcLength > 65536)
  {
    printf( "hulz - File is too big, PC Engine compression is limited to 64KB!\n" );
    return (1);
  }

  // Allocate 128KB of memory for the compresed data.

  uDstLength = 128 * 1024;
  pDstBuffer = malloc( uDstLength );

  // Compress or decompress the data using the desired method.

  if (g_fDecompress) {
    if (g_pDecompressFunc == NULL) {
      printf( "hulz - Decompression method not specified!\n" );
      return (1);
    }
    pDstFinish = (*g_pDecompressFunc)( pSrcBuffer, (int) uSrcLength,  pDstBuffer, (int) uDstLength );
  } else {
    if (g_pCompressorFunc == NULL) {
      printf( "hulz - Compression method not specified!\n" );
      return (1);
    }
    pDstFinish = (*g_pCompressorFunc)( pSrcBuffer, (int) uSrcLength,  pDstBuffer, (int) uDstLength );
  }

  if (pDstFinish == NULL)
  {
    return (1);
  }

  // Write the compressed data to the output file.

  if (!WriteBinaryFile( pDstName, pDstBuffer, pDstFinish - pDstBuffer ))
  {
    printf( "hulz - Unable to write output file \"%s\"!\n", pDstName );
    return (1);
  }

  // Free up the buffers before finishing.

  free( pDstBuffer );
  free( pSrcBuffer );

  return (0);
}



// **************************************************************************
// **************************************************************************
//
// ProcessOption ()
//

int ProcessOption ( char * pOption )

{
  // Process option string.

  switch( pOption[1] )
  {
    // Display help.

    case '?':
    case 'h':
    {
      printf
        (
          "Purpose    : Compress data with various methods used on the PC Engine\n"
          "\n"
          "Usage      : hulz [<option>] <input-file> <output-file>\n"
          "\n"
          "<option>   : Option........Description........................................\n"
          "\n"
          "             -afs          Hudson's 4-bit length, 12-bit offset, with preload\n"
          "             -tm2          Hudson's 4-bit length, 8-bit offset, older version\n"
          "             -ys4          Hudson's 4-bit length, 8-bit offset, newer version\n"
//        "             -lz8          Elmer's 16-bit length, 8-bit offset, similar to LZ4\n"
          "\n"
          "             -d            Decompress (the default is to compress)\n"
          "             -g            Use Greedy matching (the default is Lazy)\n"
          "\n"
        );

      return (0);
    }

    // Select compression method.

    case 'a':
    {
      if ( strcmp(&pOption[1], "afs") == 0 ) {
        g_pCompressorFunc = CompressAFS;
        g_pDecompressFunc = DecompressAFS;
        return (0);
      }
      break;
    }

    case 'd':
    {
      if ( strcmp(&pOption[1], "d") == 0 ) {
        g_fDecompress = true;
        return (0);
      }
      break;
    }

    case 'g':
    {
      if ( strcmp(&pOption[1], "g") == 0 ) {
        g_fLazyMatch = false;
        return (0);
      }
      break;
    }

    case 'l':
    {
      if ( strcmp(&pOption[1], "lz8") == 0 ) {
        g_pCompressorFunc = CompressLZ8;
        g_pDecompressFunc = DecompressLZ8;
        return (0);
      }
      break;
    }

    case 't':
    {
      if ( strcmp(&pOption[1], "tm2") == 0 ) {
        g_pCompressorFunc = CompressHLZ;
        g_pDecompressFunc = DecompressHLZ;
        g_iWindowFix = 0xEF;
        return (0);
      }
      break;
    }

    case 'y':
    {
      if ( strcmp(&pOption[1], "ys4") == 0 ) {
        g_pCompressorFunc = CompressHLZ;
        g_pDecompressFunc = DecompressHLZ;
        g_iWindowFix = 0x00;
        return (0);
      }
      break;
    }

    // Unknown option.

    default:
    {
      break;
    }
  }

  // It's an unrecognized option!

  printf( "hulz - Unknown option \"%s\"!\n", pOption );

  return (1);
}



// **************************************************************************
// **************************************************************************
//
// main ()
//

int main ( int argc, char **argv )

{
  // Local variables.

  int i;

  const char * pSrcName = NULL;
  const char * pDstName = NULL;

  // Sign on.

  printf("\n%s by John Brandwood\n\n", VERSION_STR);

  // Check the command line arguments.

  if (argc < 2)
  {
    ProcessOption("-?");
    goto exit;
  }

  // Read through and process the arguments.

  for (i = 1; i < argc; i++)
  {
    if ((*argv[i] == '-') || (*argv[i] == '/'))
    {
      if (ProcessOption(argv[i]) != 0) goto exit;
    }
    else
    {
      if (pSrcName == NULL) {
        pSrcName = argv[i];
      } else
      if (pDstName == NULL) {
        pDstName = argv[i];
      } else {
        printf( "hulz - Too many filenames!\n" );
        return (1);
      }
    }
  }

  // Then compress/decompress the requested file.

  if (pSrcName == NULL) {
    printf( "hulz - Source filename missing!\n" );
    return (1);
  }

  if (pDstName == NULL) {
    printf( "hulz - Destination filename missing!\n" );
    return (1);
  }

  if (ProcessFile( pSrcName, pDstName )) goto exit;

  // Program exit.
  //
  // This will either be dropped through to if everything is OK, or 'goto'ed
  // if there was an error.

exit:

  // All done.

  return (0);
}
